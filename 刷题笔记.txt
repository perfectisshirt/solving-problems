LinkedList:
1.reverse nodes in k-group（再做一遍）
first version:  reverse every k nodes,find the kth node then reverse them. the important thing is to how to connect them.
2. partition list（再做一遍）
first version: create two listnode, one is less than target and the other is greater or equal than target, last step is to connect two listnodes.
3.merge two sorted array
compare two arrays' numbers one by one then get the final array.
4.merge two sorted lists
like merge two sorted array
5.reverse linkedlist ii
just part of reverse nodes in k-group, reverse a list from m to n
6.swap two nodes in linked list（再做一遍）
first version: find v1 and v2 point first and their pre nodes.但是需要考虑v1pre和v2pre的位置以及两者是否为相邻结点。
7.swap nodes in pairs（再做一遍）
first version: I did not think one thing that declare listnode in while loop.当两个node需要交换并且重复进行的时候可以考虑放在while循环里，要不然就没办法迭代了。
8.rotate list(再做一遍）
first version:从首节点出发寻找从哪一个结点开始旋转，然后将旋转后的结点的next指向head，从而返回最终的链表。但是出现了TLE。
second version:使用双指针的思想，找到需要反转的第一个结点的前结点为tail，后一个结点为head,使用dummy.next连接需要反转的第一个结点，返回dummy.next即可。
9.reorder list
10.reverse integer
first version:转化成字符串，然后使用字符串进行reverse。
second version: 数学计算方法，但是需要考虑到int类型的溢出问题,通常想到的方式是让结果设置为long型，然后和Integer.max_value and Integer.min_value比较。还有一种方法就是反向再比较一遍，如果结果相同则没有溢出。
11.intersection of two arrays
first version:首先将两个数组排序，然后依次对比其中的数字，如果相同则放到一个temp数组中，最后将temp数组中的数传递给结果数组。因为是共同的元素，所以我们设置的temp数组的大小肯定比两个数组中的任意一个都要小于等于。要注意temp数组的下标index的赋值范围，是temp[index-1]!=nums1[i];判断语句中的index==0是为了防止后面的index-1不会出现outofboundsexception.
12.intersection of two arrays ii
这题比第一题简单，并不需要判断在最后的数组中是否会出现重复的数字。
13.linkedlist cycle
设置快慢指针来判断是否有环，slow = head, fast = head.next; slow = slow.next, fast = fast.next.next;如果快指针都遍历结束了出现了null，则false,如果出现了slow==fast,返回true;
14. linked list cycle ii
这一题的难点是没办法确定开始循环的点，上一题我们只是确定了他们第一次相遇的地方，所以在上一题的基础上我们只需要再从head出发，和slow相遇就是循环开始的点。这一题特别要注意的点就是||符号，这个是按照从左往右进行判断的，所以如果先判断fast.next==null就会发生错误。从head出发到循环开始的地方和两个指针第一次相遇的点到循环开始的地方是一样长的，所以可以通过head!=slow.next来判断，最后返回head即可。
15.maximum subarray
用到了动态规划的方法，kadane algorithms，假设存在A[0,i]Max[I]就是0到I的最大区间，要求要一个Max[I+1]=Max[I]+A[I+1],但是要保证这个值是大于零的。
16.majority number
思路一：利用java的特性，使用Collections.sort()对arraylist进行排序，只需要取出最中间的数就行了，因为题目说明了肯定存在。
思路二：对arraylist进行遍历，如果下一个数和上一个数是相同的，计数器加一。利用的原理就是如果一个数出现的次数高于其他的数字的话，那么最后赋值的一定是那个majority number.
17.majority number ii
思路一：使用hashmap，将arraylist中的数和这个数出现的次数存放在hashmap中，然后比较他们的次数取最大值。只要题目中确定有且只有一个这样的值，这个方法都适用。majority number iii就是一个例子。
思路二：
18.majority number iii
19.merge sorted array
利用从后往前的思想将两个数组的最后一个数字进行比较，依次向前进行比较。之所以这么做是因为题目给了提示A数组足够大。

动态规划：
20.paint fence (再做一遍)
0个fence为0，1个是k，2个fence，如果颜色一样是K,如果颜色不一样是k*(k-1),所以是k*k, 3个fence，如果前两个颜色一样，是k*(k-1),如果第三个和前面两个任意一种颜色相同且前面两个不一样颜色，则回到了第一种情况，如果三个颜色都不一样，则k*(k-1)*(k-2),最后结果是k*k*(k-1),总结来说就是新加入的这个栅栏是要比较和前面的相同还是不同，(k-1)*(same+diff).same的初始值是当只有一个fence的时候，和前一个颜色相同，但是前一个为0，所以初始值为0，diff的初始值就应该是k。
21.longest common subsequence（再做一遍）
要和substring区分开来，substring要求是要consecutive的。考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：

（1） 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；

（2） 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；

（3） 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。
22.