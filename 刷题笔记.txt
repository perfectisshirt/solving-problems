LinkedList:
1.reverse nodes in k-group（再做一遍）
first version:  reverse every k nodes,find the kth node then reverse them. the important thing is to how to connect them.
second version:第二遍做的时候不知道如何让k个结点依次往右平移，也就是while(true).在循环的k执行中返回值是n1并不是head.是因为每一次开始循环的时候head所在的位置就像是第一次循环时的dummy.

2. partition list（再做一遍）
first version: create two listnode, one is less than target and the other is greater or equal than target, last step is to connect two listnodes.
second version: 记得在遍历完了之后让最后一个结点的next设置为null.

3.merge two sorted array
compare two arrays' numbers one by one then get the final array.

4.merge two sorted lists
like merge two sorted array

5.reverse linkedlist ii
just part of reverse nodes in k-group, reverse a list from m to n

6.swap two nodes in linked list（再做一遍）
first version: find v1 and v2 point first and their pre nodes.但是需要考虑v1pre和v2pre的位置以及两者是否为相邻结点。如果两个节点不是相邻的，v1和v2谁在前面没有关系，但是如果两者相邻的话就需要判断谁在前面了。
second version:找到v2pre和v1pre的时候只需要对其判断是不是为Null就好，不需要对他的next判断。

7.swap nodes in pairs（再做一遍）
first version: I did not think one thing that declare listnode in while loop.当两个node需要交换并且重复进行的时候可以考虑放在while循环里，要不然就没办法迭代了。
second version: head.next!=null&&head.next.next!=null，是为了保证后面一定有两个节点，要不然会出现空指针错误。

8.rotate list(再做一遍）
first version:从首节点出发寻找从哪一个结点开始旋转，然后将旋转后的结点的next指向head，从而返回最终的链表。但是出现了TLE。
second version:使用双指针的思想，找到需要反转的第一个结点的前结点为tail，后一个结点为head,使用dummy.next连接需要反转的第一个结点，返回dummy.next即可。
third version: 只需要知道两段节点序列的最后一个结点就行了。

9.reorder list

10.reverse integer
first version:转化成字符串，然后使用字符串进行reverse。
second version: 数学计算方法，但是需要考虑到int类型的溢出问题,通常想到的方式是让结果设置为long型，然后和Integer.max_value and Integer.min_value比较。还有一种方法就是反向再比较一遍，如果结果相同则没有溢出。

11.intersection of two arrays(再做一次)
first version:首先将两个数组排序，然后依次对比其中的数字，如果相同则放到一个temp数组中，最后将temp数组中的数传递给结果数组。因为是共同的元素，所以我们设置的temp数组的大小肯定比两个数组中的任意一个都要小于等于。要注意temp数组的下标index的赋值范围，是temp[index-1]!=nums1[i];判断语句中的index==0是为了防止后面的index-1不会出现outofboundsexception.

12.intersection of two arrays ii
这题比第一题简单，并不需要判断在最后的数组中是否会出现重复的数字。

13.linkedlist cycle
设置快慢指针来判断是否有环，slow = head, fast = head.next; slow = slow.next, fast = fast.next.next;如果快指针都遍历结束了出现了null，则false,如果出现了slow==fast,返回true;

14. linked list cycle ii
这一题的难点是没办法确定开始循环的点，上一题我们只是确定了他们第一次相遇的地方，所以在上一题的基础上我们只需要再从head出发，和slow相遇就是循环开始的点。这一题特别要注意的点就是||符号，这个是按照从左往右进行判断的，所以如果先判断fast.next==null就会发生错误。从head出发到循环开始的地方和两个指针第一次相遇的点到循环开始的地方是一样长的，所以可以通过head!=slow.next来判断，最后返回head即可。

15.maximum subarray(再做一遍)
用到了动态规划的方法，kadane algorithms，假设存在A[0,i]Max[I]就是0到I的最大区间，要求要一个Max[I+1]=Max[I]+A[I+1],但是要保证这个值是大于零的。

16.majority number
思路一：利用java的特性，使用Collections.sort()对arraylist进行排序，只需要取出最中间的数就行了，因为题目说明了肯定存在。
思路二：对arraylist进行遍历，如果下一个数和上一个数是相同的，计数器加一。利用的原理就是如果一个数出现的次数高于其他的数字的话，那么最后赋值的一定是那个majority number.
17.majority number ii
思路一：使用hashmap，将arraylist中的数和这个数出现的次数存放在hashmap中，然后比较他们的次数取最大值。只要题目中确定有且只有一个这样的值，这个方法都适用。majority number iii就是一个例子。
思路二：
18.majority number iii
19.merge sorted array
利用从后往前的思想将两个数组的最后一个数字进行比较，依次向前进行比较。之所以这么做是因为题目给了提示A数组足够大。

动态规划：
我发现在做动态规划的问题的时候，非区间类的，关于求最值和可行数量的问题的时候设置数组一般的定义都是dp[i]为0到i-1表示的什么，数组的长度一般都是n+1.

1.paint fence (再做一遍)
0个fence为0，1个是k，2个fence，如果颜色一样是K,如果颜色不一样是k*(k-1),所以是k*k, 3个fence，如果前两个颜色一样，是k*(k-1),如果第三个和前面两个任意一种颜色相同且前面两个不一样颜色，则回到了第一种情况，如果三个颜色都不一样，则k*(k-1)*(k-2),最后结果是k*k*(k-1),总结来说就是新加入的这个栅栏是要比较和前面的相同还是不同，(k-1)*(same+diff).same的初始值是当只有一个fence的时候，和前一个颜色相同，但是前一个为0，所以初始值为0，diff的初始值就应该是k。

2.longest common subsequence（再做一遍）
要和substring区分开来，substring要求是要consecutive的。考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：

（1） 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；

（2） 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；

（3） 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。
设dp[i][j]，意思是A[0,i],B[0,j]中的最长相同子序列。

3.decode ways（再做一遍）
首先构建出dp数组，dp[i]表示字符串0到i-1这段数组中的解码方式数量，最麻烦的是dp[0]=1,这个初始化要注意。然后就是判断字符串i-1到i是不是能用两个字符位表示，能就判断int值是不是在10-26之间，不是的话就dp[i]=dp[i-1];

4.house robber（再做一遍）
最重要的就是判断Math.max(res[i-1], res[i-2] + A[i-1])。我们在做这道题的时候我们从递归入手慢慢的变到动态规划问题。首先我们需要知道问题是问最大值的问题，我们就会想到dp，然后我们假设是从最后一个房子开始抢，如果抢的话那么就是这间房子的价值加上index-2，或者说这间房子不抢，那么就是要抢index-1，依次递归。最后我们发现时间超过了。所以我们想到用数组来存放不断重复的数据，int []results.在我们将递推公式带入的时候发现开始值在2，那么我们就需要定义为0和1的初始值。最后我们只需要返回定义数组的最后一个值就完成了。
public int rob(int[] nums) {
        if(nums.length==0 || nums == null){
            return 0;
        }
        if(nums.length==1){
            return nums[0];
        }
        int []results = new int[nums.length];
        
        results[0] = nums[0];
        results[1] = Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;i++){
           results[i] = Math.max(results[i-2]+nums[i],results[i-1]);
        }
        return results[nums.length-1];
    }

5.house robber ii
这题和第一题不一样的地方在这是一个圈，也就是首节点和末节点是相邻结点，这两个节点要么多不选，要么选一个。可以先按照第一个题目的方法解出来，然后分别给这几种情况比较去最大值就可以了。

6. 0,1背包问题 coin change

7. maximum subarray
有一种数学的解法，这一题刚开始做的时候出现了一个误区，发现的值如果是负数就不加，这样找到的数并不能保证是连续的。这里应该舍弃的值应该是前面的数的和为负数将其舍弃也就是赋值为0，然后从后一个数开始计算。
public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            max = Math.max(sum,max);
            sum = Math.max(0,sum);
        }
        return max;
    }

8.climbStairs
这道题算是比较基本的动态规划的题目,但是有一个问题就是results[0]=1这个初始条件的判断，所以在进行边界条件的判断的时候我个人觉得可以将循环开始时的条件带入看初始值是否正确。
public int climbStairs(int n) {
        if(n<=1){
          return 1;  
        } 
        int [] results = new int[n+1];
        results[0] = 1;
        results[1] = 1;
        for(int i=2;i<=n;i++){
            results[i] = results[i-1] + results[i-2];    
        }
        return results[n];
    }
我发现这道题特别像斐波那契额数列，就是比斐波那契额数列少了一个第一个1.

深度搜索(DFS):
dfs的记忆存储方法一般都可以使用动态规划来解决。
1.subsets
这道题有几点要注意：首先是要判断其是不要求排好序的数组，如果需要排好序的在开始的时候就要Arrays.sort(nums).在dfs的过程中if(startindex==nums.length)因为题目中确定了[]也是其中的一个子集，所以不用加这一条判断。recursion的过程中i+1的选择，是因为不能出现重复的元素，所以要从下一个元素开始遍历。因为空集是自己的子集，所以在判断异常的时候要new 一个对象，也就是产生空集。
public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums.length==0 || nums==null){
            return new ArrayList<>();
        }
        
        dfs(nums,0,results,new ArrayList<Integer>());
        return results;
    }
    
    private void dfs(int[] nums, int startindex, List<List<Integer>> results, List<Integer> sub){
        results.add(new ArrayList<Integer>(sub));
        
        for(int i = startindex;i<nums.length;i++){
            sub.add(nums[i]);
            dfs(nums,i+1,results,sub);
            sub.remove(sub.size()-1);
        }
    }

2.subsets ii
这道题和之前的题目比就是要排除重复元素，所以在dos的过程中if(startindex!=i&&nums[i]==nums[i-1]),continue.如果没有i!=startindex就会出现越界的错误。
3.split string
首先要注意题目中要求分割的字符要么一个要么两个，也就是要dfs中添加判断i<startindex+2,所以取的substring就应该是startindex,i+1.还有一个要注意的问题就是判断条件是startindex==s.length();并不是sub.size()，因为子数组的大小在for循环的时候有过判断了，i<s.length().
4.permutations
这里的就不需要startindex这个循环的标志了，因为输出的长度必须是字符串的长度，所以只需要从头到尾遍历一遍就行了。在循环的时候判断语句应该是list.contains(nums[i]),这是在回溯的时候确定判断当前的数字有没有被添加过。
5.permutations ii



tree:
1.add and search word:
trie tree的题目
2.implement trie


binary tree and divide & conquer:
1.binary tree preorder traversal:（再做一遍）
这个简单的题目有几种解法，并且都是重要的思想，第一个就是recursion，这个比较简单想到。第二是divide and conquer。还有一个就是non-recursion。和这题相似的还有ignorer and after order.他们的non-recursion都是需要背诵的。

2. binary tree maximum path sum
divide&conquer 或者 traverse 都可以做。在java里面，如果在函数中不是使用了对象进行数据传递可以使用全局变量来解决这个问题，比如int类型的数据。

3.binary tree paths
这题也可以使用两种方法，一个是traverse一个是d&c. 使用d&c的时候要注意判断如果left and right are all null, if(results.size()==0)这种情况。

4.minimum subtree
因为这道题我们需要知道的是最小子树的根结点，所以我们需要计算的值有子树的结点和还有根节点，也就是说这是一个复合的结构，我们需要构建一个新的class来存储。

5.balanced binary tree
一个数的平衡是要左子树平衡，右子树平衡同时根节点也要平衡。

6.validate binary search tree（再做一遍）
left.val<root.val<=right.val.层级遍历是一个不下降的数组，但是一个不下降的数组不一定是binary search tree, like 1,1,1. 根据定义我们知道我们只需要考虑左树，右树还有根节点这三个部分，然后将左树和右树继续划分，因此我们可以使用divide and conquer.我们在判断的时候要注意这里的left和right只是两个子树集合，因此我们只需判断left.isBST和right.isBST是不是true就可以了。

7.convert binary search tree to doubly linked list(再做一遍)
这个双链表初始化的时候一个是first开头一个是链表的结尾last,如果我们知道left是空，那么results.first = node，也就是说这时候root就作为第一个节点，相反，root就是最后一个节点。如果不是空，就进行链表的插入操作。

8.flatten binary tree to linked list（再做一遍）
根据题意走一遍就可以

9.binary search tree iterator(再做一遍)
这题基本是使用了non-recursion的方法。
 
10.in-order successor in binary search tree（再做一遍）
我的第一反应是将这个bst按照inorder构成一个双链表，然后查找出目标节点的下一个节点就行了。
还有一种方法是分情况讨论，如果要找的P点就是根节点，那么successor就是他右子树的最左边的点，如果p点在左边，也就是只要p.val<root.val，那么root=root.left,successor = root.如果在右边，root=root.right。

11.search range in binary search tree
直接的方法就是对树进行inorder traverse，然后判断当前的点是不是满足条件，满足就放到arraylist里面。因为题目要求是结果是ascending order,所以想到是inorder traverse.但是一定要注意的是在helper中要对当前的点进行判断，判断是不是null，否则会出错。 为了减少遍历次数，可以判断if(root.val>k1) helper(root.left,k1,k2).可以将arraylist 对象设置成全局变量，减少迭代变量。

12.insert node in a binary search tree
第一感觉就是找插入结点的前一个结点，然后判断要插入的结点是在左边还是右边就可以了。

13.remove node in a binary search tree（再做一遍）
整体思路应该是将找到的目标节点和他的左子树进行交换，然后一直交换将要删除的点移动到叶子节点，然后让其等于空就可以了。要注意如果要删除的结点是根节点的话，我们就需要设置一个dummy结点来防止这样的情况。并且查找结点的时候要进行结点的交换，所以不仅要找到目标节点，还需要找到这个结点的parent.

14.binary tree path sum
虽然这题是binary tree，但是看完题目的要求可以肯定是用dfs来解题。有一点需要注意的是，root.val是在recursion之前就被加进去了，因为如果在过程中会被加上很多次，结果也就是错误的。

15.binary tree path sum ii（再做一遍）
这题的难点就在于如何确定起始点和结束的点。有一种方法是从后往前进行遍历，也就是说先往list中从root开始遍历，往list中放值，但是是从最后一个数一次往前遍历，如果找到和等于target的，就从此时的i开始一直到list.size()结束放入到新的list<Integer>中，然后添加到results里面。这种方法特别的地方在于我们不知道什么是开始的点，但是随着我们遍历的深入，我们都从刚刚放入的点开始计算容易往前进行查找，因为前面的点都已经放到了list里面。

16.binary tree longest consecutive sequence（再做一遍）
我的做法是沿用了上一题的想法，从后往前找，只要前面的数比后面的数小一就把后面的数放进去，便利完再加上第一个数就可以。然后在arraylist中找出长度最长的子list，返回其长度，但是TEL错误。


bfs:
1.topological sorting（再做一遍）
定义一个array list来存放graph的结点，定义一个hash map来存放结点以及每个节点的入度。每次都选择入度为0的点作为起始点放进results,然后遍历他的邻居结点。在queue的操作中出现了问题，只要找到了一个neighbor就应该将这个点的入度减去一，然后判断入度为0的点放到results中去。

2.course schedule（再做一遍）
这一题第一个难点就是构造一个图，从一个二维数组构造一个图。List[]edges = new ArrayList[numCourses];其实这就是存储每个点的邻居节点。
for(int i=0;i<numCourse;i++){
  degrees[pre[i][0]]++;
  edges[pre[i][1]].add(pre[i][0]);
}就是将有前置结点的入度加一，将新出现的结点加到前置结点的邻居节点。

3.number of islands（再做一遍）
在矩阵中的点可以转换成坐标对象，生成做标准换数组。另外在bfs的过程中需要进行边界判断，传递的参数要是对象，因为对象的属性是两边改变的。

4.binary tree level order traversal
这是一道标准的bfs的题目。

5.search graph nodes
这也是一道标准的bfs的题目，为了避免已经判断过的点再次进行判断我们使用hashset来存储数据。

6.knight shortest path（再做一遍）
这道题遇到了一个问题就是不知道在什么地方程序跳出来，以及在满足什么条件后steps+1.这里不仅仅需要判断是不是点的坐标越界了而且还需要判断点是不是false.因为是只能往8个方向走，也就是说这8个满足条件的方向就可以认为是走了一步。

7.zombie in matrix（再做一遍）
这道题不能用和上一题完全相同的方法去解答。首先题目的意思是找到多久人类全部变成僵尸，所以我们需要设置一个变量来统计天数，同时还需要一个变量来统计人数，因为当人数为0的时候就结束判断了。我们使用queue来存放僵尸的位置。所以在使用bfs的时候需要明白我们在queue中到底存放的是什么数据。因为存放的是僵尸，所以判断是不是在边界里面的条件就应该是当前的点是不是人类。

8.graph valid tree（再做一遍）
一个valid的tree首先不能有环，也就是说edges.length!=n-1;因为是无序的，所以我们使用hashset来存储邻居节点。满足的条件就是放在hash表中的点的个数等于所有点的个数。

9.clone graph
我们使用一个hashmap来存储以前的点和现在的点，为的是让这两个点能够对应。因为graph包含点和边，所以我们除了要复制点还要复制边。

10.binary tree serialization

11.number of islands ii（再做一遍）
union-find方法。因为这道题考察的是动态的联通图。建立一个hash map,建立两个id之间的联系，初始化的时候hm.put(id,id).id = x*m+y.hashmap中第二个参数是第一个的parent，也就是第一个点的root,判断两个点是不是建立了连接就是判断这两个点的root是不是相同，如果不相同也就是说明两者不是联通的，就union，也就是father(id,id);同时islands—-。如果两者相同就是表示这两者联通。
while(fa!=father.get(fa)) {
                temp = father.get(fa);
                father.put(fa, parent) ;
                fa = temp;
            }这一步的操作的意思是因为每一步都往上递增了，所以就不再是balanced tree，所以我们需要优化他们的时间复杂度。amortized constant time complexity.

data structure:
1. hash function
2.high five
3.k closet points
4. kth largest element
5. kth largest element ii
6. top k largest numbers
7 rehashing
8.merge k sorted lists
9. ugly number
10. ugly number ii
11. strStr ii
12.flatten 2D vector
13. top k largest numbers ii
14. merge k sorted arrays
15. top k frequent words
16. heapify
17. longest consecutive sequence

数据结构题目：
1.LRU（再做一遍）
首先我们要明白我们放进数据结构的不是一个简单的数，而是一个对象，也就是说我们需要进行数据抽象化，假设每次放到数据结构的是一个node,这个node 包含key,value没问题，但是我们也设计了pre和next指针，方便查找调用具体的结点。最新插入的点都是插到尾结点的，所以我们每插入一个结点都不仅仅是将结点方到hashmap中还要判断是否超出了cache的capacity，超过了就要把头结点后的第一个结点删除。get结点的函数是要判断是不是有该结点，如果有就将该结点删除，然后将这个结点移到最后一个结点，因为该节点是最近才使用的结点。之所以使用双链表是因为我们需要对链表进行移除和插入操作，双链表比单链表操作要简单。为了避免查找特定的值的结点的时候我们都要进行链表遍历，我们设置了hashmap。在set函数中判断了有要插入的结点就应该return.判断需要插入的结点在不在链表中是get(key)!=-1,而不能用hs.containsKey(key)。这个还是要从题目的定义出发，题目给了get(key)的定义，if the key exists in the cache.

private class node{
        int val;
        int key;
        node pre = null;
        node next = null;
        node(int key,int val){
            this.val = val;
            this.key = key;
        }
    }
    int capacity;
    node head = new node(-1,-1);
    node tail = new node(-1,-1);
    HashMap<Integer,node> hm = new HashMap<Integer,node>();
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        if(!hm.containsKey(key)){
            return -1;
        }
        node cur = hm.get(key);
        cur.pre.next = cur.next;
        cur.next.pre = cur.pre;
        toTail(cur);
        return hm.get(key).val;
    }
    
    public void put(int key, int value) {
        //如果原来里面就有这个结点，就只需要更新点的值就行了
        if(get(key)!=-1){
            hm.get(key).val = value;
            return;
        }
        if(hm.size()==capacity){
            hm.remove(head.next.key);
            head.next = head.next.next;
            head.next.pre = head;
        }
        
        
        node cur = new node(key,value);
        hm.put(key,cur);
        toTail(cur);
    }
    
    //其实就是尾插
    private void toTail(node current){
       current.pre = tail.pre;
        tail.pre = current;
        current.pre.next = current;
        current.next = tail;
    }
}

2.two sum(hash map)
因为这道题涉及到数和这个数所在的位置的对应关系，所以我们想到使用hashmap来做，但是在做的过程中我犯了一个错误，就是先往hashmap里面放数字，然后再逐个判断，这样就会存在一个问题，就是相同的数字的话位置就会被覆盖。应该将问题转换成减数和被减数两个数各自有对应的关系。因为题目中说了肯定有解，所以不需要进行数组是否有效的判断。
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int[] results = new int[2];
        for(int i=0;i<nums.length;i++){
            int diff = target-nums[i];
            if(hm.containsKey(diff)){
                results[0] = i;
                results[1] = hm.get(diff);
            }else{
                hm.put(nums[i],i);
            }
        }
        return results;
    }

3.move zeroes(array)
这道题是让我们把所有的0都放到数组的最后并且不能改变其他数字的相对位置，我首先想到的方法就是对数组进行遍历，使用双指针的办法，如果我们第一个指针的值是0，第二个不是，那么就把两个数交换，如果第一个数不是0那么就把指向第一个数的指针往后移，如果第一个数是0，第二个数也是0就把第二个指针往后移。这个思想其实就是第一个指针指向非零的数，第二个指针指向零，这样遍历完就可以保证所有的零都在后面，而且因为遇到零就换了位置，所以相对的位置也不会改变。
public void moveZeroes(int[] nums) {
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]==0&&nums[j]!=0){
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }else if(nums[j] == 0){
                    continue;
                }else{
                    break;
                }
            }
        }
    }

4.add binary(string)
我想到的办法是首先判断两个字符串的长度，长度小的那个字符串在末尾补齐长度加0。然后将两个字符串从末尾开始加，最后将字符串reverse过来就可以了。
还有一种方法是直接对两个字符串从末尾向前遍历，每一位的值其实就是两个字符串在相应位置的值的和加上carry位的值，因为每一位的值就只有0或者1，所以只需要将和对2取余。carry位则是sum/2，因为在二进制中是满2加一。
public String addBinary(String a, String b) {
        if(a == null || a.length()==0){
            return b;
        }
        if(b==null || b.length()==0){
            return a;
        }
        
        StringBuilder sb = new StringBuilder();
        int indexa = a.length()-1;
        int indexb = b.length()-1;
        int carry = 0;
        while(indexa>=0 || indexb>=0){
            int sum = carry;
            if(indexa>=0) sum += a.charAt(indexa--) -'0';
            if(indexb>=0) sum += b.charAt(indexb--) - '0';
            
            carry = sum/2;
            sb.append(sum % 2);
        }
        if(carry!=0) sb.append(carry);
        return sb.reverse().toString();
        
    }
两个char类型的数字相减其实是他们对应的aspic码相减，string builder类型中有一个reverse的方法将字符串反过来。

5. First bad version (binary tree)
找第一个是坏的东西，从中间开始找，如果中间的是坏的，说明前面有第一个坏的，反之，就向后找。
public int firstBadVersion(int n) {
        if(n <= 0) return 0;
        
        int start = 1;
        int end = n;
        while(start+1<end){
            int mid = start+(end-start)/2;
            if(isBadVersion(mid)){
                end = mid;
            }else{
                start = mid;
            }
        }
        if(isBadVersion(start)) return start;
        if(isBadVersion(end)) return end;
        
        return 0;
    }

6.binary tree paths(tree)
divide and conquer:
 public List<String> binaryTreePaths(TreeNode root) {
        if(root == null){
            return new ArrayList<String>();
        }
        
        List<String> left = binaryTreePaths(root.left);
        List<String> right = binaryTreePaths(root.right);
        
        
        List<String> results = new ArrayList<String>();
        
            for(String s:left){
                results.add(root.val+"->"+s);
            }
        
         
            for(String s:right){
                results.add(root.val+"->"+s);
            }
        
        
        if (results.size() == 0) {
            results.add("" + root.val);
        }
        return results;
    }

dfs:
这道题最直观的做法应该是深搜，因为题目的意思就满足深搜的条件。但是这道题我们要注意的一点就是在iteration的过程中每次都是new StringBuilder(sb),因为如果不是这样，每一次都会将之前的结果重复计算一遍。
public List<String> binaryTreePaths(TreeNode root) {
        List<String> results = new ArrayList<String>();
        if(root == null){
            return results;
        }
        
        helper(root,results,new StringBuilder());
        return results;
    }
    
    private void helper(TreeNode root, List<String> results, StringBuilder sb){
        if(root.left==null && root.right==null){
            sb.append(root.val);
            results.add(sb.toString());
            return;
        }
        sb.append(root.val);
        sb.append("->");
       if(root.left!=null){
           helper(root.left,results,new StringBuilder(sb));
       }
        if(root.right!=null){
           helper(root.right,results,new StringBuilder(sb));
       }
    }

7.read N characters given read4(string) 再做一遍
刚开始题目没有读懂。后来明白，我们需要设置一个临时数组，这个数组的大小为4，每次从这个数组中读数read4(tmp)，读出来的数存到count中，意思就是说这个数组中有多少数，如果count==0就说明数读完了，如果不是就进行判断，如果读出来的数的大小比n-res小，也就是说需要读出的数的多少减去已有的数就是需要的数，那就把count存储给一个变量，然后从res开始将数字放到目标数组中。
public int read(char[] buf, int n) {
       char[] tmp = new char[4];
       int res = 0, count = -1;
       while (res < n) {
            count = read4(tmp);
            if (count == 0)
                   break;
            int r = n - res < count ? n - res : count;
            for (int i = 0; i < r; i++) {
                buf[res++] = tmp[i];
            }
        }
           return res;
    }

8.diameter of binary tree(binary tree, divide and conquer)
求任意两个点的距离最长，那就是左子树的最长的高加上右子树最长的高。只是这道题比maximum depth of binary tree多了一个判断，就是我们要取left+right的最大值，所以加上Math.max(max,left+right).
private int max = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return max;
    }
    
    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        
        max = Math.max(max, left + right);
        
        return Math.max(left, right) + 1;
    }

9.maximum depth of binary tree(binary tree, divide and conquer)
 public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        
        return Math.max(left,right)+1;
    }

10.reverse linked list(linked list)
public ListNode reverseList(ListNode head) {
        if(head == null) return null;
        
        ListNode pre = null;
        while(head!=null){
            ListNode temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }

11.merge sorted array(array)
因为说明了要把2放到1中，所以这是in-place的操作。一个tricky 的方法就是把2先放进去，然后进行排序就可以了。
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int count = 0;
        for(int i=m;i<m+n;i++){
            nums1[i] = nums2[count];
            count++;
        }
        Arrays.sort(nums1);
    }
当然，在面试的时候要想其他的办法。我想到了双指针，也就是一个指针指向数组1的最后一个元素，另一个指针指向数组2的最后一个元素，然后进行比较，大的入选到数组1的最后，数组1的最终有效大小是m+n.
 public void merge(int[] nums1, int m, int[] nums2, int n) {
        
        int index = m+n-1;
        int index1 = m-1;
        int index2 = n-1;
        while(index1>=0 && index2>=0){
            if(nums1[index1]>nums2[index2]){
                nums1[index--] = nums1[index1--];
            }else{
                nums1[index--] = nums2[index2--];
            }
        }
        while(index1>=0){
            nums1[index--] = nums1[index1--];
        }
        while(index2>=0){
            nums1[index--] = nums2[index2--];
        }
    }

12.roman to integer(math , string)
这道题最重要的是要知道罗马数的表示方式和规则，I=1,V=5,X=10,L=50,C=100,D=500,M=1000。然后要知道罗马数转换成整数的公式，如果前一个数比后一个数大，加上这个数，反之，就减去前一个数的两倍再加上当前的数。
public static int charToInt(char c) {  
        int data = 0;  
  
        switch (c) {  
            case 'I':  
                data = 1;  
                break;  
            case 'V':  
                data = 5;  
                break;  
            case 'X':  
                data = 10;  
                break;  
            case 'L':  
                data = 50;  
                break;  
            case 'C':  
                data = 100;  
                break;  
            case 'D':  
                data = 500;  
                break;  
            case 'M':  
                data = 1000;  
                break;  
        }  
  
        return data;  
    }  
  
    public static int romanToInt(String s) {  
        int i, total, pre, cur;  
  
        total = charToInt(s.charAt(0));  
  
        for (i = 1; i < s.length(); i++) {  
            pre = charToInt(s.charAt(i - 1));  
            cur = charToInt(s.charAt(i));  
  
            if (cur <= pre) {  
                total += cur;  
            } else {  
                total = total - pre * 2 + cur;  
            }  
        }  
  
        return total;  
    }  

13.regular expression matching

14.evaluate reverse polish notation(stack)
这是一道标准的使用stack来存储计算的题目，这应该是中序的表达，要练习前序和后续的题目，以及他们之间的转换。这道题有一个边界case的考虑，就是如果只有一个值的情况。我们应该在default的情况里直接将当前的值赋给results.
public int evalRPN(String[] tokens) {
        Stack<String> stack = new Stack<String>();
        int results = 0;
        for(int i=0;i<tokens.length;i++){
            switch(tokens[i]){
                case "*":
                    results = Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(results));
                    break;
                case "/":
                    int divide = Integer.parseInt(stack.pop());
                    int temp = Integer.parseInt(stack.pop());
                    results = temp / divide;
                    stack.push(String.valueOf(results));
                    break;
                case "+":
                    results = Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(results));
                    break;
                case "-":
                    int second = Integer.parseInt(stack.pop());
                    int first = Integer.parseInt(stack.pop());
                    results = first - second;
                    stack.push(String.valueOf(results));
                    break;
                default:
                   stack.push(tokens[i]);
                    results = Integer.parseInt(tokens[i]);
                    break;
            }
        }
        return results;
    }

15.valid palindrome(string )
这道题一开始有一个单词没懂，ignoring cases就是说如果是字母就忽视大小写。只需要在判断到是大写的时候将大写的字母变成小写的就行了。但是我还是犯了一个错误，就是’a’+(c-‘A’)这个的返回值是一个整数，要进行类型转换成char.
public boolean isPalindrome(String s) {
        if(s==null || s.length()==0){
            return true;
        }
        
        char[] array = new char[s.length()];
        int index = 0;
        for(int i=0;i<s.length();i++){
            if((s.charAt(i)>='0'&&s.charAt(i)<='9')||(s.charAt(i)>='a'&&s.charAt(i)<='z')){
                array[index++] = s.charAt(i);
            }
            if(s.charAt(i)>='A'&&s.charAt(i)<='Z'){
                array[index++] = changeToSmall(s.charAt(i));
            }
        }
        for(int i=0;i<index;i++){
            if(array[i]!=array[index-i-1]){
                return false;
            }
        }
        return true;
    }
    
    private char changeToSmall(char c){
        return (char)('a'+ (c-'A'));
    }

16.meeting rooms(sort)再做一遍
这道题如果用暴力方法解答的话，需要考虑太多的情况，比如pre.start and after.end的关系还有pre.end和after.start的关系。如果我们将所有的数据的起始时间进行比较，我们就只需要考虑一种情况了。但是我们还需要考虑几种边界情况，如果排序的时候两个点的start相等（不存在，肯定会返回false），pre.end和后一个start相等的关系（可以）。Arrays.sort的排序不仅仅可以使用在数字数组上，字符数组上，还可以对对象数组进行排序。有一点要注意的就是每次比较完要将最晚时间更新为当前的最晚时间。
public boolean canAttendMeetings(Interval[] intervals) {
        if(intervals == null || intervals.length==0) return true;
        
        Arrays.sort(intervals,new Comparator<Interval>(){
            public int compare(Interval i1, Interval i2){
                return i1.start - i2.start;
            }
        });
        
        for(int i=1;i<intervals.length;i++){
            int tail = intervals[i-1].end;
            if(tail > intervals[i].start){
                return false;
            }else{
                tail = intervals[i].end; 
            }
        }
        
        return true;
    }

17.valid palindrome ii(string)
这道题在考虑的时候因为涉及到了palindrome我就想到了首尾指针，因为题目中提到了说最多只能删除一个字母，也就是说在只有可能在第一次遇到不同字母的时候开始考虑要不要删除这个字母，但是双指针就会遇到到底是将左边的指针往右还是右边的指针往左。所以我们使用substring的方法将剪切出两个子字符串，这两个子字符串只要有一个是true就是true.还有这个结果的boolean类型初始化为true,为的是防止出现这样一个问题,aba.
public boolean validPalindrome(String s) {
        boolean results = true;
        int start = 0;
        int end = s.length()-1;
        while(start<end){
             if(s.charAt(start)==s.charAt(end)){
                 start++;
                 end--;
             }else{
                 results = palindrome(s.substring(start+1,end+1))||palindrome(s.substring(start,end));
                 break;
             }
        }
         return results;
    }
    
    private boolean palindrome(String s){
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=s.charAt(s.length()-i-1)){
                return false;
            }
        }
        return true;
    }

18.first unique character in a string
这道题一开始的想法是使用hashmap来解决，就是将s进行遍历，然后将每一个字符出现的次数放进去，但是有一个问题，就是要判断哪个是第一不重复的数。然后我想到了放数组里，这个数组就是26字符的数组，因为字符有顺序并且一个萝卜一个坑。我们只需要用当前的字符减去a就可以得到这个字符的位置了，所以最后我们从前往后遍历的时候出现的字符出现的次数显示也是按照出现顺序来定的。
public int firstUniqChar(String s) {
        int index = -1;
        int[] results = new int[26];
        for(int i=0;i<s.length();i++){
            results[s.charAt(i)-'a']++;
        }
        
        for(int i=0;i<s.length();i++){
            if(results[s.charAt(i)-'a']==1){
                index = i;
                break;
            }
        }
        return index;
    }

19.permutation(dfs)再做一遍

20.add two numbers(linkedlist)
这道题最重要的一点就是数字相加的进位处理问题。这样的处理也可以处理二进制的数字问题，carry = temp/10,二进制就是temp/2;temp%=10,二进制就是temp%2.
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode results = new ListNode(0);
        ListNode point = results;
        int carry = 0;
        while(l1!=null || l2!=null){
            int n1 = 0;
            int n2 = 0;
            if(l1!=null){
                n1 = l1.val;
                l1 = l1.next;
            }
            if(l2!=null){
                n2 = l2.val;
                l2 = l2.next;
            }
            int temp = n1 + n2 + carry;
            carry = temp/10;
            temp %= 10;
            point.next = new ListNode(temp);
            point = point.next;
        }
        if(carry>0){
            point.next = new ListNode(carry);
        }
        return results.next;
    }

21.longest substring without repeating characters
我已开始想到的做法是用一个hashset来存放不一样的值，但是发现最后取得最大值是subsequence，并不是substring.
public int lengthOfLongestSubstring(String s) {
        boolean[] array = new boolean[256];
        int j = 0;
        int ans = 0;
        for(int i=0;i<s.length();i++){
            while(j<s.length()&&array[s.charAt(j)]==false){
                array[s.charAt(j)]=true;
                ans = Math.max(ans,j-i+1);
                j++;
            }
            array[s.charAt(i)]=false;
        }
        return ans;
    }

22.longest palindrome substring

23.palindrome number
首先需要知道负数在不在考虑范围内，需要和interviwer沟通，然后就是将数字转换的时候需要防止数字溢出。我第一遍在做的时候将x直接进行运算，这样x的值就被变化了，就不能直接进行比较了。
if(x<0){
            return false;
        }
        int results = 0;
        int cur = x;
        
        while(x!=0){
            int temp = results*10 + x%10;
            if(temp/10 == results){
                results = temp;
                x /=10;
            }else{
                return false;
            }
        }
        if(cur == results){
            return true;
        }else return false;

24.longest  common prefix
选择整个字符串数组中最长的common prefix，最暴力的想法就是每两个字符串进行比较，取出其中最长的子串，然后第三个字符串和这个最长的子串进行比较，以此类推。
if(strs.length==0 || strs==null){
            return new String();
        }
        
        String prefix = strs[0];
        for(int i=1;i<strs.length;i++){
            int j = 0;
            while(j<prefix.length()&&j<strs[i].length()&&strs[i].charAt(j)==prefix.charAt(j)){
                j++;
            }
            if(j==0){
                return "";
            }
            prefix = prefix.substring(0,j);
        }
        return prefix;

25.merge two sorted lists
简单的对linked list的比较，dummy node 的应用。
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode point = dummy;
        while(l1!=null && l2!=null){
            if(l1.val>l2.val){
                point.next = l2;
                l2 = l2.next;
                point = point.next;
            }else{
                point.next = l1;
                l1 = l1.next;
                point = point.next;
            }
        }
        while(l1!=null){
            point.next = l1;
            l1 = l1.next;
            point = point.next;
        }
        while(l2!=null){
            point.next = l2;
            l2 = l2.next;
            point = point.next;
        }
        return dummy.next;
    }

26.remove duplicates from sorted array
因为这道题已经交代了是sorted array，所以不用排序，要不然第一部应该是排序。我们使用一个变量来存储应该插入的不同的元素的位置，另一个变量进行比较。
public int removeDuplicates(int[] nums) {
        // Arrays.sort(nums);
        int j = 0;
        for(int i=1;i<nums.length;i++){
            if(nums[i]==nums[j]){
                continue;
            }else{
                nums[++j] = nums[i];
            }
        }
        return j+1;
    }

27.remove element
这题和上一题很像，也是需要有一个变量来存储不是target的数的位置，所以只要发现有数不相等就把数组中的位置填满，然后变量往后走。
public int removeElement(int[] nums, int val) {
        int j = 0;
        int cur = 0;
        for(int i=0;i<nums.length;i++){
            cur = nums[i];
            if(cur!=val){
                nums[j++]=cur;
            }
        }
        return j;
    }

28.divide two integers（重看一遍）
这道题用到了位运算。

29.valid parentheses(stack)
这是一道简单的栈的问题，但是在做的过程中出现了几个问题。第一是stack是否为空，我在判断的时候是如果发现了右边比配的字符就取出栈中最上面的，但是我忘了判断此时栈是否为空，isEmpty()。第二个问题是最后return的值，我应该考虑到只有当其中的值全部被取出去了才是true,因为如果原来string只有一个{,那么只存进去就不为空。
public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for(char c:s.toCharArray()){
            if(c=='{'||c=='['||c=='('){
                stack.push(c);
            }
            if(c=='}'){
                if(stack.isEmpty()||stack.pop()!='{')
                    return false;
            }
            if(c==']'){
                if(stack.isEmpty()||stack.pop()!='[')
                    return false;
            }
            if(c==')'){
                if(stack.isEmpty()||stack.pop()!='(')
                    return false;
            }
        }
        return stack.isEmpty();
    }

30.implement strStr()
这道题用暴力解法，我第一次写的时候遇到了几个问题，第一个是边界问题，如果两个字符串都是””,则应该返回0.第二个是第一个循环的判断条件是<=haystack.length()-needle.length()。第三个是返回条件是j==needle.length(),也就是说当needle被全部循环了一遍才是结束的条件。
public int strStr(String haystack, String needle) {
        if(haystack==null||needle==null){
            return -1;
        }
        if(haystack.length()==0&&needle.length()==0){
            return 0;
        }
        int i=0 ;
        for(;i<=haystack.length()-needle.length();i++){
            int j= 0 ;
            for(;j<needle.length();j++){
                if(needle.charAt(j)!=haystack.charAt(j+i)){
                    break;
                }
            }
            if(j==needle.length()){
                return i;
            }
        }
        return -1;
    }

除了暴力解法，我们还可以使用hash function，robin-carp方法解决。比如aabb,找ab，我们可以逐个去找其hashcode匹配的字符串。我们在做的时候一定要小心溢出的问题，也就是溢出hashtable的capacity,所以我们在求其阶乘的时候要%BASE.
    private int BASE = 10000000;
    public int strStr(String source, String target) { 
        if(source==null || target==null) return -1;
        int m  = target.length();
        if(m==0) return 0;
        
        int targetcode = 0;
        for(int i=0;i<m;i++){
            targetcode = (targetcode*31 + target.charAt(i))%BASE;
        }
        
        int pow = 1;
        for(int i=0;i<m;i++){
            pow = (pow*31)%BASE;
        }
        
        int sourcecode = 0;
        for(int i=0;i<source.length();i++){
            sourcecode = (sourcecode*31+source.charAt(i))%BASE;
            
            if(i<m-1){
                continue;
            }
            
            if(i>=m){
                sourcecode = sourcecode - (source.charAt(i-m)*pow)%BASE;
                if(sourcecode<0){
                    sourcecode += BASE;
                }
            }
            
            if(sourcecode==targetcode){
                if(source.substring(i-m+1,i+1).equals(target)){
                    return i-m+1;
                }
            }
        }
        return -1;
        
    }

31.rotate array
这是一道简单的数组的题目，这道题可以利用公式[A-B-]-,A-代表A的reverse。
public void rotate(int[] nums, int k) {
        if(k==0 || nums.length==0 || nums==null) return;
        k %= nums.length ;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    public void reverse(int[] array,int start,int end){
       while(start<=end){
           int temp = array[end];
           array[end] = array[start];
           array[start] = temp;
           start++;
           end--;
       }
    }

32.remove invalid parentheses

33.swap nodes in pairs(linkedlist)
这道题也是linkedlist的经典题目，关于节点交换的题目都需要知道要交换的点的前一个节点，有些需要知道交换节点的后一个节点。这道题的难点在于要想到每两个交换的节点都是在变化的，所以我们申明指针指向这两个节点和他们的前节点的时候需要在循环中。
public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        ListNode point = dummy;
        dummy.next = head;
       
        while(head!=null && head.next!=null){
            ListNode p1 = head;
            ListNode p2 = head.next;
            point.next = p2;
            p1.next = p2.next;
            p2.next = p1;
            
            point = head;
            head = head.next;
        }
        
        return dummy.next;
    }

34.search in rotated sorted array(binary tree)

35.zigzag conversion(string)
按照一定规律排列读取string,就是将规律装换成数学表达式。这道题有几个注意的点，第一个是因为最后字符串的读取是换了一个方式，所以我们需要新建一个stringbuilder，将字符串读取添加。第二个问题就是字符读取过程是一个反复的过程，向下到低端就要反弹回去，所以要使用两个循环，一个是向下循环，一个是向上循环。
public String convert(String s, int numRows) {
        char[] array = s.toCharArray();
        int len = array.length;
        
        StringBuilder []sb = new StringBuilder[numRows];
        for(int i=0;i<numRows;i++){
            sb[i] = new StringBuilder();
        }
        
        int i = 0;
        while(i<len){
            for(int index = 0;index<numRows && i<len;index++){
                sb[index].append(array[i++]);
            }
            for(int index = numRows-2;index>=1 && i<len;index--){
                sb[index].append(array[i++]);
            }
        }
        for(int index=1;index<numRows;index++){
            sb[0].append(sb[index]);
        }
        
        return sb[0].toString();
    }

36.string to integer(atoi)
这题就是需要考虑全面一点，是否在integer的范围里面，小数怎么办，非法字符怎么办,string是null怎么办,还要考虑这个数字是不是负数，string当中的空格怎么办。
trim()是把起始和结尾的空格都删除了。首先就应该将前后的空格删除，然后判断当前的第一个字符是什么符号，并做好标记。逐个判断是否为数字，如果是的话就加进去。数字的读取 sum = sum *10+str.charAt(i)-‘0’;因为要判断数字是否超出了整数的表示范围，所以我们需要将和设置为long,再根据符号判断是否超出上界还是下界。要注意的是如果是负数，和是要乘以（-1）的。
public int myAtoi(String str) {
        if(str==null || str.length()==0) 
            return 0;
        str = str.trim();
        
        int signal = 1,len = str.length(),start = 0;
        long sum = 0;
        if(str.charAt(0)=='+'){
            signal = 1;
            start++;
        }else if(str.charAt(0)=='-'){
            signal = -1;
            start++;
        }
        
        for(int i=start;i<len;i++){
            if(!Character.isDigit(str.charAt(i))){
                return (int)sum * signal;
            }
            sum = sum*10+str.charAt(i)-'0';
            if(signal==1 && sum>Integer.MAX_VALUE){
                return Integer.MAX_VALUE;
            }
            if(signal==-1 && (-1) * sum<Integer.MIN_VALUE){
                return Integer.MIN_VALUE;
            }
        }
        return (int)sum*signal;
    }

37.container with most water
这道题一开始我理解错了题意，两条垂直的线分别代表的是两个高度，要盛水的话肯定是按短的算，并不是计算两根线和x轴组成的图形的面积。这道题可以用双指针的思想来解决，分别从头和尾开始向中间进发。因为end-start无论是左边往右走还是右边往左走都是减少的，所以不可以不用考虑。但是高度都是短的提取，所以都是要紧着短的来，目的是为了找到更短的。
public int maxArea(int[] height) {
        
        int max = Integer.MIN_VALUE;
        int start = 0;
        int end = height.length-1;
        
        while(start<end){
            max = Math.max(max,Math.min(height[start],height[end])*(end-start));
            if(height[start]>height[end]){
                end--;
            }else start++;
        }
        return max;
    }

38.remove nth node from end of list
这道题和之前删除结点的题目一样都是需要找到要删除结点的前一个结点。但是这样的题目有一个问题就是考虑的问题比较多，最大的问题就是空指针的问题，也就是寻路指针在遍历的时候他自己和next指针是不是为空都是需要进行判断的，要不然就会出错。
 public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null || n==0){
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        ListNode point = dummy;
        
        for(int i=0;i<n;i++){
            head = head.next;
            if(head==null){
                return null;
            }
        }
        
        while(head!=null && head.next!=null){
            head = head.next;
            point = point.next;
        }
        
        point.next = point.next.next;
        return dummy.next;
    }

39.generate parentheses
这道题我一开始的想法是，建立一个stack来判断是否所有的括号都是配对的，然后使用dfs的方法来生成最后的答案。但是在操作过程中我发现我把问题复杂了，还有一个问题是我们不好直接构建原始数组使其包含所有的左括号和右括号。
这道题毫无疑问是使用dfs的方法来解决，但是解决的方法其实就是按照题目的意思来构造list就行了，定义一个左括号的下标，一个右括号的下标，当str的数量满足n*2的时候就放到list中，如果open<n小就应该加上一个左括号，如果close<open就加上一个右括号。
 public List<String> generateParenthesis(int n) {
        List<String> results = new ArrayList<String>();
        helper(results,"",0,0,n);
        return results;
    }
    
    private void helper(List<String> results, String str, int open, int  close, int max){
       if(str.length() == max*2){
           results.add(str);
           return;
       }
       if(open<max){
           helper(results,str+"(",open+1,close,max);
       }
       if(close<open){
           helper(results,str+")",open,close+1,max);
       }
    }

40.combination sum
