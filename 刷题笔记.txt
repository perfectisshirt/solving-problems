LinkedList:
1.reverse nodes in k-group（再做一遍）
first version:  reverse every k nodes,find the kth node then reverse them. the important thing is to how to connect them.
second version:第二遍做的时候不知道如何让k个结点依次往右平移，也就是while(true).在循环的k执行中返回值是n1并不是head.是因为每一次开始循环的时候head所在的位置就像是第一次循环时的dummy.

2. partition list（再做一遍）
first version: create two listnode, one is less than target and the other is greater or equal than target, last step is to connect two listnodes.
second version: 记得在遍历完了之后让最后一个结点的next设置为null.

3.merge two sorted array
compare two arrays' numbers one by one then get the final array.

4.merge two sorted lists
like merge two sorted array

5.reverse linkedlist ii
just part of reverse nodes in k-group, reverse a list from m to n

6.swap two nodes in linked list（再做一遍）
first version: find v1 and v2 point first and their pre nodes.但是需要考虑v1pre和v2pre的位置以及两者是否为相邻结点。如果两个节点不是相邻的，v1和v2谁在前面没有关系，但是如果两者相邻的话就需要判断谁在前面了。
second version:找到v2pre和v1pre的时候只需要对其判断是不是为Null就好，不需要对他的next判断。

7.swap nodes in pairs（再做一遍）
first version: I did not think one thing that declare listnode in while loop.当两个node需要交换并且重复进行的时候可以考虑放在while循环里，要不然就没办法迭代了。
second version: head.next!=null&&head.next.next!=null，是为了保证后面一定有两个节点，要不然会出现空指针错误。

8.rotate list(再做一遍）
first version:从首节点出发寻找从哪一个结点开始旋转，然后将旋转后的结点的next指向head，从而返回最终的链表。但是出现了TLE。
second version:使用双指针的思想，找到需要反转的第一个结点的前结点为tail，后一个结点为head,使用dummy.next连接需要反转的第一个结点，返回dummy.next即可。
third version: 只需要知道两段节点序列的最后一个结点就行了。

9.reorder list

10.reverse integer
first version:转化成字符串，然后使用字符串进行reverse。
second version: 数学计算方法，但是需要考虑到int类型的溢出问题,通常想到的方式是让结果设置为long型，然后和Integer.max_value and Integer.min_value比较。还有一种方法就是反向再比较一遍，如果结果相同则没有溢出。

11.intersection of two arrays(再做一次)
first version:首先将两个数组排序，然后依次对比其中的数字，如果相同则放到一个temp数组中，最后将temp数组中的数传递给结果数组。因为是共同的元素，所以我们设置的temp数组的大小肯定比两个数组中的任意一个都要小于等于。要注意temp数组的下标index的赋值范围，是temp[index-1]!=nums1[i];判断语句中的index==0是为了防止后面的index-1不会出现outofboundsexception.

12.intersection of two arrays ii
这题比第一题简单，并不需要判断在最后的数组中是否会出现重复的数字。

13.linkedlist cycle
设置快慢指针来判断是否有环，slow = head, fast = head.next; slow = slow.next, fast = fast.next.next;如果快指针都遍历结束了出现了null，则false,如果出现了slow==fast,返回true;

14. linked list cycle ii
这一题的难点是没办法确定开始循环的点，上一题我们只是确定了他们第一次相遇的地方，所以在上一题的基础上我们只需要再从head出发，和slow相遇就是循环开始的点。这一题特别要注意的点就是||符号，这个是按照从左往右进行判断的，所以如果先判断fast.next==null就会发生错误。从head出发到循环开始的地方和两个指针第一次相遇的点到循环开始的地方是一样长的，所以可以通过head!=slow.next来判断，最后返回head即可。

15.maximum subarray(再做一遍)
用到了动态规划的方法，kadane algorithms，假设存在A[0,i]Max[I]就是0到I的最大区间，要求要一个Max[I+1]=Max[I]+A[I+1],但是要保证这个值是大于零的。

19.merge sorted array
利用从后往前的思想将两个数组的最后一个数字进行比较，依次向前进行比较。之所以这么做是因为题目给了提示A数组足够大。

动态规划：
我发现在做动态规划的问题的时候，非区间类的，关于求最值和可行数量的问题的时候设置数组一般的定义都是dp[i]为0到i-1表示的什么，数组的长度一般都是n+1.

1.paint fence (再做一遍)
0个fence为0，1个是k，2个fence，如果颜色一样是K,如果颜色不一样是k*(k-1),所以是k*k, 3个fence，如果前两个颜色一样，是k*(k-1),如果第三个和前面两个任意一种颜色相同且前面两个不一样颜色，则回到了第一种情况，如果三个颜色都不一样，则k*(k-1)*(k-2),最后结果是k*k*(k-1),总结来说就是新加入的这个栅栏是要比较和前面的相同还是不同，(k-1)*(same+diff).same的初始值是当只有一个fence的时候，和前一个颜色相同，但是前一个为0，所以初始值为0，diff的初始值就应该是k。

2.longest common subsequence（再做一遍）
要和substring区分开来，substring要求是要consecutive的。考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：

（1） 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；

（2） 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；

（3） 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。
设dp[i][j]，意思是A[0,i],B[0,j]中的最长相同子序列。



4.house robber（再做一遍）
最重要的就是判断Math.max(res[i-1], res[i-2] + A[i-1])。我们在做这道题的时候我们从递归入手慢慢的变到动态规划问题。首先我们需要知道问题是问最大值的问题，我们就会想到dp，然后我们假设是从最后一个房子开始抢，如果抢的话那么就是这间房子的价值加上index-2，或者说这间房子不抢，那么就是要抢index-1，依次递归。最后我们发现时间超过了。所以我们想到用数组来存放不断重复的数据，int []results.在我们将递推公式带入的时候发现开始值在2，那么我们就需要定义为0和1的初始值。最后我们只需要返回定义数组的最后一个值就完成了。
public int rob(int[] nums) {
        if(nums.length==0 || nums == null){
            return 0;
        }
        if(nums.length==1){
            return nums[0];
        }
        int []results = new int[nums.length];
        
        results[0] = nums[0];
        results[1] = Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;i++){
           results[i] = Math.max(results[i-2]+nums[i],results[i-1]);
        }
        return results[nums.length-1];
    }

5.house robber ii
这题和第一题不一样的地方在这是一个圈，也就是首节点和末节点是相邻结点，这两个节点要么多不选，要么选一个。可以先按照第一个题目的方法解出来，然后分别给这几种情况比较去最大值就可以了。

6. 0,1背包问题 coin change

7. maximum subarray
有一种数学的解法，这一题刚开始做的时候出现了一个误区，发现的值如果是负数就不加，这样找到的数并不能保证是连续的。这里应该舍弃的值应该是前面的数的和为负数将其舍弃也就是赋值为0，然后从后一个数开始计算。
public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            max = Math.max(sum,max);
            sum = Math.max(0,sum);
        }
        return max;
    }

8.climbStairs
这道题算是比较基本的动态规划的题目,但是有一个问题就是results[0]=1这个初始条件的判断，所以在进行边界条件的判断的时候我个人觉得可以将循环开始时的条件带入看初始值是否正确。
public int climbStairs(int n) {
        if(n<=1){
          return 1;  
        } 
        int [] results = new int[n+1];
        results[0] = 1;
        results[1] = 1;
        for(int i=2;i<=n;i++){
            results[i] = results[i-1] + results[i-2];    
        }
        return results[n];
    }
我发现这道题特别像斐波那契额数列，就是比斐波那契额数列少了一个第一个1.

深度搜索(DFS):
dfs的记忆存储方法一般都可以使用动态规划来解决。
1.subsets
这道题有几点要注意：首先是要判断其是不要求排好序的数组，如果需要排好序的在开始的时候就要Arrays.sort(nums).在dfs的过程中if(startindex==nums.length)因为题目中确定了[]也是其中的一个子集，所以不用加这一条判断。recursion的过程中i+1的选择，是因为不能出现重复的元素，所以要从下一个元素开始遍历。因为空集是自己的子集，所以在判断异常的时候要new 一个对象，也就是产生空集。
public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums.length==0 || nums==null){
            return new ArrayList<>();
        }
        
        dfs(nums,0,results,new ArrayList<Integer>());
        return results;
    }
    
    private void dfs(int[] nums, int startindex, List<List<Integer>> results, List<Integer> sub){
        results.add(new ArrayList<Integer>(sub));
        
        for(int i = startindex;i<nums.length;i++){
            sub.add(nums[i]);
            dfs(nums,i+1,results,sub);
            sub.remove(sub.size()-1);
        }
    }

2.subsets ii
这道题和之前的题目比就是要排除重复元素，所以在dos的过程中if(startindex!=i&&nums[i]==nums[i-1]),continue.如果没有i!=startindex就会出现越界的错误。
3.split string
首先要注意题目中要求分割的字符要么一个要么两个，也就是要dfs中添加判断i<startindex+2,所以取的substring就应该是startindex,i+1.还有一个要注意的问题就是判断条件是startindex==s.length();并不是sub.size()，因为子数组的大小在for循环的时候有过判断了，i<s.length().
4.permutations
这里的就不需要startindex这个循环的标志了，因为输出的长度必须是字符串的长度，所以只需要从头到尾遍历一遍就行了。在循环的时候判断语句应该是list.contains(nums[i]),这是在回溯的时候确定判断当前的数字有没有被添加过。
5.permutations ii



tree:
1.add and search word:
trie tree的题目
2.implement trie


binary tree and divide & conquer:
1.binary tree preorder traversal:（再做一遍）
这个简单的题目有几种解法，并且都是重要的思想，第一个就是recursion，这个比较简单想到。第二是divide and conquer。还有一个就是non-recursion。和这题相似的还有ignorer and after order.他们的non-recursion都是需要背诵的。

2. binary tree maximum path sum
divide&conquer 或者 traverse 都可以做。在java里面，如果在函数中不是使用了对象进行数据传递可以使用全局变量来解决这个问题，比如int类型的数据。

3.binary tree paths
这题也可以使用两种方法，一个是traverse一个是d&c. 使用d&c的时候要注意判断如果left and right are all null, if(results.size()==0)这种情况。

4.minimum subtree
因为这道题我们需要知道的是最小子树的根结点，所以我们需要计算的值有子树的结点和还有根节点，也就是说这是一个复合的结构，我们需要构建一个新的class来存储。

5.balanced binary tree
一个数的平衡是要左子树平衡，右子树平衡同时根节点也要平衡。

6.validate binary search tree（再做一遍）
left.val<root.val<=right.val.层级遍历是一个不下降的数组，但是一个不下降的数组不一定是binary search tree, like 1,1,1. 根据定义我们知道我们只需要考虑左树，右树还有根节点这三个部分，然后将左树和右树继续划分，因此我们可以使用divide and conquer.我们在判断的时候要注意这里的left和right只是两个子树集合，因此我们只需判断left.isBST和right.isBST是不是true就可以了。

7.convert binary search tree to doubly linked list(再做一遍)
这个双链表初始化的时候一个是first开头一个是链表的结尾last,如果我们知道left是空，那么results.first = node，也就是说这时候root就作为第一个节点，相反，root就是最后一个节点。如果不是空，就进行链表的插入操作。

8.flatten binary tree to linked list（再做一遍）
根据题意走一遍就可以

9.binary search tree iterator(再做一遍)
这题基本是使用了non-recursion的方法。
 
10.in-order successor in binary search tree（再做一遍）
我的第一反应是将这个bst按照inorder构成一个双链表，然后查找出目标节点的下一个节点就行了。
还有一种方法是分情况讨论，如果要找的P点就是根节点，那么successor就是他右子树的最左边的点，如果p点在左边，也就是只要p.val<root.val，那么root=root.left,successor = root.如果在右边，root=root.right。

11.search range in binary search tree
直接的方法就是对树进行inorder traverse，然后判断当前的点是不是满足条件，满足就放到arraylist里面。因为题目要求是结果是ascending order,所以想到是inorder traverse.但是一定要注意的是在helper中要对当前的点进行判断，判断是不是null，否则会出错。 为了减少遍历次数，可以判断if(root.val>k1) helper(root.left,k1,k2).可以将arraylist 对象设置成全局变量，减少迭代变量。

12.insert node in a binary search tree
第一感觉就是找插入结点的前一个结点，然后判断要插入的结点是在左边还是右边就可以了。

13.remove node in a binary search tree（再做一遍）
整体思路应该是将找到的目标节点和他的左子树进行交换，然后一直交换将要删除的点移动到叶子节点，然后让其等于空就可以了。要注意如果要删除的结点是根节点的话，我们就需要设置一个dummy结点来防止这样的情况。并且查找结点的时候要进行结点的交换，所以不仅要找到目标节点，还需要找到这个结点的parent.

14.binary tree path sum
虽然这题是binary tree，但是看完题目的要求可以肯定是用dfs来解题。有一点需要注意的是，root.val是在recursion之前就被加进去了，因为如果在过程中会被加上很多次，结果也就是错误的。

15.binary tree path sum ii（再做一遍）
这题的难点就在于如何确定起始点和结束的点。有一种方法是从后往前进行遍历，也就是说先往list中从root开始遍历，往list中放值，但是是从最后一个数一次往前遍历，如果找到和等于target的，就从此时的i开始一直到list.size()结束放入到新的list<Integer>中，然后添加到results里面。这种方法特别的地方在于我们不知道什么是开始的点，但是随着我们遍历的深入，我们都从刚刚放入的点开始计算容易往前进行查找，因为前面的点都已经放到了list里面。

16.binary tree longest consecutive sequence（再做一遍）
我的做法是沿用了上一题的想法，从后往前找，只要前面的数比后面的数小一就把后面的数放进去，便利完再加上第一个数就可以。然后在arraylist中找出长度最长的子list，返回其长度，但是TEL错误。


bfs:
1.topological sorting（再做一遍）
定义一个array list来存放graph的结点，定义一个hash map来存放结点以及每个节点的入度。每次都选择入度为0的点作为起始点放进results,然后遍历他的邻居结点。在queue的操作中出现了问题，只要找到了一个neighbor就应该将这个点的入度减去一，然后判断入度为0的点放到results中去。

2.course schedule（再做一遍）
这一题第一个难点就是构造一个图，从一个二维数组构造一个图。List[]edges = new ArrayList[numCourses];其实这就是存储每个点的邻居节点。
for(int i=0;i<numCourse;i++){
  degrees[pre[i][0]]++;
  edges[pre[i][1]].add(pre[i][0]);
}就是将有前置结点的入度加一，将新出现的结点加到前置结点的邻居节点。

3.number of islands（再做一遍）
在矩阵中的点可以转换成坐标对象，生成做标准换数组。另外在bfs的过程中需要进行边界判断，传递的参数要是对象，因为对象的属性是两边改变的。

4.binary tree level order traversal
这是一道标准的bfs的题目。

5.search graph nodes
这也是一道标准的bfs的题目，为了避免已经判断过的点再次进行判断我们使用hashset来存储数据。

6.knight shortest path（再做一遍）
这道题遇到了一个问题就是不知道在什么地方程序跳出来，以及在满足什么条件后steps+1.这里不仅仅需要判断是不是点的坐标越界了而且还需要判断点是不是false.因为是只能往8个方向走，也就是说这8个满足条件的方向就可以认为是走了一步。

7.zombie in matrix（再做一遍）
这道题不能用和上一题完全相同的方法去解答。首先题目的意思是找到多久人类全部变成僵尸，所以我们需要设置一个变量来统计天数，同时还需要一个变量来统计人数，因为当人数为0的时候就结束判断了。我们使用queue来存放僵尸的位置。所以在使用bfs的时候需要明白我们在queue中到底存放的是什么数据。因为存放的是僵尸，所以判断是不是在边界里面的条件就应该是当前的点是不是人类。

8.graph valid tree（再做一遍）
一个valid的tree首先不能有环，也就是说edges.length!=n-1;因为是无序的，所以我们使用hashset来存储邻居节点。满足的条件就是放在hash表中的点的个数等于所有点的个数。

9.clone graph
我们使用一个hashmap来存储以前的点和现在的点，为的是让这两个点能够对应。因为graph包含点和边，所以我们除了要复制点还要复制边。

10.binary tree serialization

11.number of islands ii（再做一遍）
union-find方法。因为这道题考察的是动态的联通图。建立一个hash map,建立两个id之间的联系，初始化的时候hm.put(id,id).id = x*m+y.hashmap中第二个参数是第一个的parent，也就是第一个点的root,判断两个点是不是建立了连接就是判断这两个点的root是不是相同，如果不相同也就是说明两者不是联通的，就union，也就是father(id,id);同时islands—-。如果两者相同就是表示这两者联通。
while(fa!=father.get(fa)) {
                temp = father.get(fa);
                father.put(fa, parent) ;
                fa = temp;
            }这一步的操作的意思是因为每一步都往上递增了，所以就不再是balanced tree，所以我们需要优化他们的时间复杂度。amortized constant time complexity.

data structure:
1. hash function
2.high five
3.k closet points
4. kth largest element
5. kth largest element ii
6. top k largest numbers
7 rehashing
8.merge k sorted lists
9. ugly number
10. ugly number ii
11. strStr ii
12.flatten 2D vector
13. top k largest numbers ii
14. merge k sorted arrays
15. top k frequent words
16. heapify
17. longest consecutive sequence

数据结构题目：
1.LRU（再做一遍）
首先我们要明白我们放进数据结构的不是一个简单的数，而是一个对象，也就是说我们需要进行数据抽象化，假设每次放到数据结构的是一个node,这个node 包含key,value没问题，但是我们也设计了pre和next指针，方便查找调用具体的结点。最新插入的点都是插到尾结点的，所以我们每插入一个结点都不仅仅是将结点方到hashmap中还要判断是否超出了cache的capacity，超过了就要把头结点后的第一个结点删除。get结点的函数是要判断是不是有该结点，如果有就将该结点删除，然后将这个结点移到最后一个结点，因为该节点是最近才使用的结点。之所以使用双链表是因为我们需要对链表进行移除和插入操作，双链表比单链表操作要简单。为了避免查找特定的值的结点的时候我们都要进行链表遍历，我们设置了hashmap。在set函数中判断了有要插入的结点就应该return.判断需要插入的结点在不在链表中是get(key)!=-1,而不能用hs.containsKey(key)。这个还是要从题目的定义出发，题目给了get(key)的定义，if the key exists in the cache.

private class node{
        int val;
        int key;
        node pre = null;
        node next = null;
        node(int key,int val){
            this.val = val;
            this.key = key;
        }
    }
    int capacity;
    node head = new node(-1,-1);
    node tail = new node(-1,-1);
    HashMap<Integer,node> hm = new HashMap<Integer,node>();
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        if(!hm.containsKey(key)){
            return -1;
        }
        node cur = hm.get(key);
        cur.pre.next = cur.next;
        cur.next.pre = cur.pre;
        toTail(cur);
        return hm.get(key).val;
    }
    
    public void put(int key, int value) {
        //如果原来里面就有这个结点，就只需要更新点的值就行了
        if(get(key)!=-1){
            hm.get(key).val = value;
            return;
        }
        if(hm.size()==capacity){
            hm.remove(head.next.key);
            head.next = head.next.next;
            head.next.pre = head;
        }
        
        
        node cur = new node(key,value);
        hm.put(key,cur);
        toTail(cur);
    }
    
    //其实就是尾插
    private void toTail(node current){
       current.pre = tail.pre;
        tail.pre = current;
        current.pre.next = current;
        current.next = tail;
    }
}

2.two sum(hash map)
因为这道题涉及到数和这个数所在的位置的对应关系，所以我们想到使用hashmap来做，但是在做的过程中我犯了一个错误，就是先往hashmap里面放数字，然后再逐个判断，这样就会存在一个问题，就是相同的数字的话位置就会被覆盖。应该将问题转换成减数和被减数两个数各自有对应的关系。因为题目中说了肯定有解，所以不需要进行数组是否有效的判断。
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int[] results = new int[2];
        for(int i=0;i<nums.length;i++){
            int diff = target-nums[i];
            if(hm.containsKey(diff)){
                results[0] = i;
                results[1] = hm.get(diff);
            }else{
                hm.put(nums[i],i);
            }
        }
        return results;
    }

3.move zeroes(array)
这道题是让我们把所有的0都放到数组的最后并且不能改变其他数字的相对位置，我首先想到的方法就是对数组进行遍历，使用双指针的办法，如果我们第一个指针的值是0，第二个不是，那么就把两个数交换，如果第一个数不是0那么就把指向第一个数的指针往后移，如果第一个数是0，第二个数也是0就把第二个指针往后移。这个思想其实就是第一个指针指向非零的数，第二个指针指向零，这样遍历完就可以保证所有的零都在后面，而且因为遇到零就换了位置，所以相对的位置也不会改变。
public void moveZeroes(int[] nums) {
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]==0&&nums[j]!=0){
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }else if(nums[j] == 0){
                    continue;
                }else{
                    break;
                }
            }
        }
    }

4.add binary(string)
我想到的办法是首先判断两个字符串的长度，长度小的那个字符串在末尾补齐长度加0。然后将两个字符串从末尾开始加，最后将字符串reverse过来就可以了。
还有一种方法是直接对两个字符串从末尾向前遍历，每一位的值其实就是两个字符串在相应位置的值的和加上carry位的值，因为每一位的值就只有0或者1，所以只需要将和对2取余。carry位则是sum/2，因为在二进制中是满2加一。
public String addBinary(String a, String b) {
        if(a == null || a.length()==0){
            return b;
        }
        if(b==null || b.length()==0){
            return a;
        }
        
        StringBuilder sb = new StringBuilder();
        int indexa = a.length()-1;
        int indexb = b.length()-1;
        int carry = 0;
        while(indexa>=0 || indexb>=0){
            int sum = carry;
            if(indexa>=0) sum += a.charAt(indexa--) -'0';
            if(indexb>=0) sum += b.charAt(indexb--) - '0';
            
            carry = sum/2;
            sb.append(sum % 2);
        }
        if(carry!=0) sb.append(carry);
        return sb.reverse().toString();
        
    }
两个char类型的数字相减其实是他们对应的aspic码相减，string builder类型中有一个reverse的方法将字符串反过来。

5. First bad version (binary tree)
找第一个是坏的东西，从中间开始找，如果中间的是坏的，说明前面有第一个坏的，反之，就向后找。
public int firstBadVersion(int n) {
        if(n <= 0) return 0;
        
        int start = 1;
        int end = n;
        while(start+1<end){
            int mid = start+(end-start)/2;
            if(isBadVersion(mid)){
                end = mid;
            }else{
                start = mid;
            }
        }
        if(isBadVersion(start)) return start;
        if(isBadVersion(end)) return end;
        
        return 0;
    }

6.binary tree paths(tree)
divide and conquer:
 public List<String> binaryTreePaths(TreeNode root) {
        if(root == null){
            return new ArrayList<String>();
        }
        
        List<String> left = binaryTreePaths(root.left);
        List<String> right = binaryTreePaths(root.right);
        
        
        List<String> results = new ArrayList<String>();
        
            for(String s:left){
                results.add(root.val+"->"+s);
            }
        
         
            for(String s:right){
                results.add(root.val+"->"+s);
            }
        
        
        if (results.size() == 0) {
            results.add("" + root.val);
        }
        return results;
    }

dfs:
这道题最直观的做法应该是深搜，因为题目的意思就满足深搜的条件。但是这道题我们要注意的一点就是在iteration的过程中每次都是new StringBuilder(sb),因为如果不是这样，每一次都会将之前的结果重复计算一遍。
public List<String> binaryTreePaths(TreeNode root) {
        List<String> results = new ArrayList<String>();
        if(root == null){
            return results;
        }
        
        helper(root,results,new StringBuilder());
        return results;
    }
    
    private void helper(TreeNode root, List<String> results, StringBuilder sb){
        if(root.left==null && root.right==null){
            sb.append(root.val);
            results.add(sb.toString());
            return;
        }
        sb.append(root.val);
        sb.append("->");
       if(root.left!=null){
           helper(root.left,results,new StringBuilder(sb));
       }
        if(root.right!=null){
           helper(root.right,results,new StringBuilder(sb));
       }
    }

7.read N characters given read4(string) 再做一遍
刚开始题目没有读懂。后来明白，我们需要设置一个临时数组，这个数组的大小为4，每次从这个数组中读数read4(tmp)，读出来的数存到count中，意思就是说这个数组中有多少数，如果count==0就说明数读完了，如果不是就进行判断，如果读出来的数的大小比n-res小，也就是说需要读出的数的多少减去已有的数就是需要的数，那就把count存储给一个变量，然后从res开始将数字放到目标数组中。
public int read(char[] buf, int n) {
       char[] tmp = new char[4];
       int res = 0, count = -1;
       while (res < n) {
            count = read4(tmp);
            if (count == 0)
                   break;
            int r = n - res < count ? n - res : count;
            for (int i = 0; i < r; i++) {
                buf[res++] = tmp[i];
            }
        }
           return res;
    }

8.diameter of binary tree(binary tree, divide and conquer)
求任意两个点的距离最长，那就是左子树的最长的高加上右子树最长的高。只是这道题比maximum depth of binary tree多了一个判断，就是我们要取left+right的最大值，所以加上Math.max(max,left+right).
private int max = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return max;
    }
    
    private int maxDepth(TreeNode root) {
        if (root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        
        max = Math.max(max, left + right);
        
        return Math.max(left, right) + 1;
    }

9.maximum depth of binary tree(binary tree, divide and conquer)
 public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        
        return Math.max(left,right)+1;
    }

10.reverse linked list(linked list)
public ListNode reverseList(ListNode head) {
        if(head == null) return null;
        
        ListNode pre = null;
        while(head!=null){
            ListNode temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }

11.merge sorted array(array)
因为说明了要把2放到1中，所以这是in-place的操作。一个tricky 的方法就是把2先放进去，然后进行排序就可以了。
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int count = 0;
        for(int i=m;i<m+n;i++){
            nums1[i] = nums2[count];
            count++;
        }
        Arrays.sort(nums1);
    }
当然，在面试的时候要想其他的办法。我想到了双指针，也就是一个指针指向数组1的最后一个元素，另一个指针指向数组2的最后一个元素，然后进行比较，大的入选到数组1的最后，数组1的最终有效大小是m+n.
 public void merge(int[] nums1, int m, int[] nums2, int n) {
        
        int index = m+n-1;
        int index1 = m-1;
        int index2 = n-1;
        while(index1>=0 && index2>=0){
            if(nums1[index1]>nums2[index2]){
                nums1[index--] = nums1[index1--];
            }else{
                nums1[index--] = nums2[index2--];
            }
        }
        while(index1>=0){
            nums1[index--] = nums1[index1--];
        }
        while(index2>=0){
            nums1[index--] = nums2[index2--];
        }
    }

12.roman to integer(math , string)
这道题最重要的是要知道罗马数的表示方式和规则，I=1,V=5,X=10,L=50,C=100,D=500,M=1000。然后要知道罗马数转换成整数的公式，如果前一个数比后一个数大，加上这个数，反之，就减去前一个数的两倍再加上当前的数。
public static int charToInt(char c) {  
        int data = 0;  
  
        switch (c) {  
            case 'I':  
                data = 1;  
                break;  
            case 'V':  
                data = 5;  
                break;  
            case 'X':  
                data = 10;  
                break;  
            case 'L':  
                data = 50;  
                break;  
            case 'C':  
                data = 100;  
                break;  
            case 'D':  
                data = 500;  
                break;  
            case 'M':  
                data = 1000;  
                break;  
        }  
  
        return data;  
    }  
  
    public static int romanToInt(String s) {  
        int i, total, pre, cur;  
  
        total = charToInt(s.charAt(0));  
  
        for (i = 1; i < s.length(); i++) {  
            pre = charToInt(s.charAt(i - 1));  
            cur = charToInt(s.charAt(i));  
  
            if (cur <= pre) {  
                total += cur;  
            } else {  
                total = total - pre * 2 + cur;  
            }  
        }  
  
        return total;  
    }  

13.regular expression matching

14.evaluate reverse polish notation(stack)
这是一道标准的使用stack来存储计算的题目，这应该是中序的表达，要练习前序和后续的题目，以及他们之间的转换。这道题有一个边界case的考虑，就是如果只有一个值的情况。我们应该在default的情况里直接将当前的值赋给results.
public int evalRPN(String[] tokens) {
        Stack<String> stack = new Stack<String>();
        int results = 0;
        for(int i=0;i<tokens.length;i++){
            switch(tokens[i]){
                case "*":
                    results = Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(results));
                    break;
                case "/":
                    int divide = Integer.parseInt(stack.pop());
                    int temp = Integer.parseInt(stack.pop());
                    results = temp / divide;
                    stack.push(String.valueOf(results));
                    break;
                case "+":
                    results = Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(results));
                    break;
                case "-":
                    int second = Integer.parseInt(stack.pop());
                    int first = Integer.parseInt(stack.pop());
                    results = first - second;
                    stack.push(String.valueOf(results));
                    break;
                default:
                   stack.push(tokens[i]);
                    results = Integer.parseInt(tokens[i]);
                    break;
            }
        }
        return results;
    }

15.valid palindrome(string )
这道题一开始有一个单词没懂，ignoring cases就是说如果是字母就忽视大小写。只需要在判断到是大写的时候将大写的字母变成小写的就行了。但是我还是犯了一个错误，就是’a’+(c-‘A’)这个的返回值是一个整数，要进行类型转换成char.
public boolean isPalindrome(String s) {
        if(s==null || s.length()==0){
            return true;
        }
        
        char[] array = new char[s.length()];
        int index = 0;
        for(int i=0;i<s.length();i++){
            if((s.charAt(i)>='0'&&s.charAt(i)<='9')||(s.charAt(i)>='a'&&s.charAt(i)<='z')){
                array[index++] = s.charAt(i);
            }
            if(s.charAt(i)>='A'&&s.charAt(i)<='Z'){
                array[index++] = changeToSmall(s.charAt(i));
            }
        }
        for(int i=0;i<index;i++){
            if(array[i]!=array[index-i-1]){
                return false;
            }
        }
        return true;
    }
    
    private char changeToSmall(char c){
        return (char)('a'+ (c-'A'));
    }

16.meeting rooms(sort)再做一遍
这道题如果用暴力方法解答的话，需要考虑太多的情况，比如pre.start and after.end的关系还有pre.end和after.start的关系。如果我们将所有的数据的起始时间进行比较，我们就只需要考虑一种情况了。但是我们还需要考虑几种边界情况，如果排序的时候两个点的start相等（不存在，肯定会返回false），pre.end和后一个start相等的关系（可以）。Arrays.sort的排序不仅仅可以使用在数字数组上，字符数组上，还可以对对象数组进行排序。有一点要注意的就是每次比较完要将最晚时间更新为当前的最晚时间。
public boolean canAttendMeetings(Interval[] intervals) {
        if(intervals == null || intervals.length==0) return true;
        
        Arrays.sort(intervals,new Comparator<Interval>(){
            public int compare(Interval i1, Interval i2){
                return i1.start - i2.start;
            }
        });
        
        for(int i=1;i<intervals.length;i++){
            int tail = intervals[i-1].end;
            if(tail > intervals[i].start){
                return false;
            }else{
                tail = intervals[i].end; 
            }
        }
        
        return true;
    }

17.valid palindrome ii(string)
这道题在考虑的时候因为涉及到了palindrome我就想到了首尾指针，因为题目中提到了说最多只能删除一个字母，也就是说在只有可能在第一次遇到不同字母的时候开始考虑要不要删除这个字母，但是双指针就会遇到到底是将左边的指针往右还是右边的指针往左。所以我们使用substring的方法将剪切出两个子字符串，这两个子字符串只要有一个是true就是true.还有这个结果的boolean类型初始化为true,为的是防止出现这样一个问题,aba.
public boolean validPalindrome(String s) {
        boolean results = true;
        int start = 0;
        int end = s.length()-1;
        while(start<end){
             if(s.charAt(start)==s.charAt(end)){
                 start++;
                 end--;
             }else{
                 results = palindrome(s.substring(start+1,end+1))||palindrome(s.substring(start,end));
                 break;
             }
        }
         return results;
    }
    
    private boolean palindrome(String s){
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=s.charAt(s.length()-i-1)){
                return false;
            }
        }
        return true;
    }

18.first unique character in a string
这道题一开始的想法是使用hashmap来解决，就是将s进行遍历，然后将每一个字符出现的次数放进去，但是有一个问题，就是要判断哪个是第一不重复的数。然后我想到了放数组里，这个数组就是26字符的数组，因为字符有顺序并且一个萝卜一个坑。我们只需要用当前的字符减去a就可以得到这个字符的位置了，所以最后我们从前往后遍历的时候出现的字符出现的次数显示也是按照出现顺序来定的。
public int firstUniqChar(String s) {
        int index = -1;
        int[] results = new int[26];
        for(int i=0;i<s.length();i++){
            results[s.charAt(i)-'a']++;
        }
        
        for(int i=0;i<s.length();i++){
            if(results[s.charAt(i)-'a']==1){
                index = i;
                break;
            }
        }
        return index;
    }

19.permutation(dfs)再做一遍
这是一道经典的dfs的题目，在题目中所有的数都是distinct，所以不需要考虑duplicates的问题。但是在Helper类里面我们需要加入一个set,都是将数组遍历完，但是没有startindex，我们需要保证放进去的数都是不重复的。
public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums==null) return results;
        if(nums.length==0){
            results.add(new ArrayList<Integer>());
            return results;
        }
        
        List<Integer> permutation = new ArrayList<Integer>();
        Set<Integer> set = new HashSet<Integer>();
        helper(results,permutation,nums,set);
        return results;
    }
    
    private void helper(List<List<Integer>> results, List<Integer> permutation, int[] nums, Set<Integer> set){
        if(permutation.size()==nums.length){
            results.add(new ArrayList<Integer>(permutation));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(set.contains(nums[i])){
                continue;
            }
            
            permutation.add(nums[i]);
            set.add(nums[i]);
            helper(results,permutation,nums,set);
            set.remove(nums[i]);
            permutation.remove(permutation.size()-1);
        }
    }

20.add two numbers(linkedlist)
这道题最重要的一点就是数字相加的进位处理问题。这样的处理也可以处理二进制的数字问题，carry = temp/10,二进制就是temp/2;temp%=10,二进制就是temp%2.
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode results = new ListNode(0);
        ListNode point = results;
        int carry = 0;
        while(l1!=null || l2!=null){
            int n1 = 0;
            int n2 = 0;
            if(l1!=null){
                n1 = l1.val;
                l1 = l1.next;
            }
            if(l2!=null){
                n2 = l2.val;
                l2 = l2.next;
            }
            int temp = n1 + n2 + carry;
            carry = temp/10;
            temp %= 10;
            point.next = new ListNode(temp);
            point = point.next;
        }
        if(carry>0){
            point.next = new ListNode(carry);
        }
        return results.next;
    }

21.longest substring without repeating characters
我已开始想到的做法是用一个hashset来存放不一样的值，但是发现最后取得最大值是subsequence，并不是substring.
public int lengthOfLongestSubstring(String s) {
        boolean[] array = new boolean[256];
        int j = 0;
        int ans = 0;
        for(int i=0;i<s.length();i++){
            while(j<s.length()&&array[s.charAt(j)]==false){
                array[s.charAt(j)]=true;
                ans = Math.max(ans,j-i+1);
                j++;
            }
            array[s.charAt(i)]=false;
        }
        return ans;
    }

22.longest palindrome substring

23.palindrome number
首先需要知道负数在不在考虑范围内，需要和interviwer沟通，然后就是将数字转换的时候需要防止数字溢出。我第一遍在做的时候将x直接进行运算，这样x的值就被变化了，就不能直接进行比较了。
if(x<0){
            return false;
        }
        int results = 0;
        int cur = x;
        
        while(x!=0){
            int temp = results*10 + x%10;
            if(temp/10 == results){
                results = temp;
                x /=10;
            }else{
                return false;
            }
        }
        if(cur == results){
            return true;
        }else return false;

24.longest  common prefix
选择整个字符串数组中最长的common prefix，最暴力的想法就是每两个字符串进行比较，取出其中最长的子串，然后第三个字符串和这个最长的子串进行比较，以此类推。
if(strs.length==0 || strs==null){
            return new String();
        }
        
        String prefix = strs[0];
        for(int i=1;i<strs.length;i++){
            int j = 0;
            while(j<prefix.length()&&j<strs[i].length()&&strs[i].charAt(j)==prefix.charAt(j)){
                j++;
            }
            if(j==0){
                return "";
            }
            prefix = prefix.substring(0,j);
        }
        return prefix;

25.merge two sorted lists
简单的对linked list的比较，dummy node 的应用。
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode point = dummy;
        while(l1!=null && l2!=null){
            if(l1.val>l2.val){
                point.next = l2;
                l2 = l2.next;
                point = point.next;
            }else{
                point.next = l1;
                l1 = l1.next;
                point = point.next;
            }
        }
        while(l1!=null){
            point.next = l1;
            l1 = l1.next;
            point = point.next;
        }
        while(l2!=null){
            point.next = l2;
            l2 = l2.next;
            point = point.next;
        }
        return dummy.next;
    }

26.remove duplicates from sorted array
因为这道题已经交代了是sorted array，所以不用排序，要不然第一部应该是排序。我们使用一个变量来存储应该插入的不同的元素的位置，另一个变量进行比较。
public int removeDuplicates(int[] nums) {
        // Arrays.sort(nums);
        int j = 0;
        for(int i=1;i<nums.length;i++){
            if(nums[i]==nums[j]){
                continue;
            }else{
                nums[++j] = nums[i];
            }
        }
        return j+1;
    }

27.remove element
这题和上一题很像，也是需要有一个变量来存储不是target的数的位置，所以只要发现有数不相等就把数组中的位置填满，然后变量往后走。
public int removeElement(int[] nums, int val) {
        int j = 0;
        int cur = 0;
        for(int i=0;i<nums.length;i++){
            cur = nums[i];
            if(cur!=val){
                nums[j++]=cur;
            }
        }
        return j;
    }

28.divide two integers（重看一遍）
这道题用到了位运算。

29.valid parentheses(stack)
这是一道简单的栈的问题，但是在做的过程中出现了几个问题。第一是stack是否为空，我在判断的时候是如果发现了右边比配的字符就取出栈中最上面的，但是我忘了判断此时栈是否为空，isEmpty()。第二个问题是最后return的值，我应该考虑到只有当其中的值全部被取出去了才是true,因为如果原来string只有一个{,那么只存进去就不为空。
public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        for(char c:s.toCharArray()){
            if(c=='{'||c=='['||c=='('){
                stack.push(c);
            }
            if(c=='}'){
                if(stack.isEmpty()||stack.pop()!='{')
                    return false;
            }
            if(c==']'){
                if(stack.isEmpty()||stack.pop()!='[')
                    return false;
            }
            if(c==')'){
                if(stack.isEmpty()||stack.pop()!='(')
                    return false;
            }
        }
        return stack.isEmpty();
    }

30.implement strStr()
这道题用暴力解法，我第一次写的时候遇到了几个问题，第一个是边界问题，如果两个字符串都是””,则应该返回0.第二个是第一个循环的判断条件是<=haystack.length()-needle.length()。第三个是返回条件是j==needle.length(),也就是说当needle被全部循环了一遍才是结束的条件。
public int strStr(String haystack, String needle) {
        if(haystack==null||needle==null){
            return -1;
        }
        if(haystack.length()==0&&needle.length()==0){
            return 0;
        }
        int i=0 ;
        for(;i<=haystack.length()-needle.length();i++){
            int j= 0 ;
            for(;j<needle.length();j++){
                if(needle.charAt(j)!=haystack.charAt(j+i)){
                    break;
                }
            }
            if(j==needle.length()){
                return i;
            }
        }
        return -1;
    }

除了暴力解法，我们还可以使用hash function，robin-carp方法解决。比如aabb,找ab，我们可以逐个去找其hashcode匹配的字符串。我们在做的时候一定要小心溢出的问题，也就是溢出hashtable的capacity,所以我们在求其阶乘的时候要%BASE.
    private int BASE = 10000000;
    public int strStr(String source, String target) { 
        if(source==null || target==null) return -1;
        int m  = target.length();
        if(m==0) return 0;
        
        int targetcode = 0;
        for(int i=0;i<m;i++){
            targetcode = (targetcode*31 + target.charAt(i))%BASE;
        }
        
        int pow = 1;
        for(int i=0;i<m;i++){
            pow = (pow*31)%BASE;
        }
        
        int sourcecode = 0;
        for(int i=0;i<source.length();i++){
            sourcecode = (sourcecode*31+source.charAt(i))%BASE;
            
            if(i<m-1){
                continue;
            }
            
            if(i>=m){
                sourcecode = sourcecode - (source.charAt(i-m)*pow)%BASE;
                if(sourcecode<0){
                    sourcecode += BASE;
                }
            }
            
            if(sourcecode==targetcode){
                if(source.substring(i-m+1,i+1).equals(target)){
                    return i-m+1;
                }
            }
        }
        return -1;
        
    }

31.rotate array
这是一道简单的数组的题目，这道题可以利用公式[A-B-]-,A-代表A的reverse。
public void rotate(int[] nums, int k) {
        if(k==0 || nums.length==0 || nums==null) return;
        k %= nums.length ;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    public void reverse(int[] array,int start,int end){
       while(start<=end){
           int temp = array[end];
           array[end] = array[start];
           array[start] = temp;
           start++;
           end--;
       }
    }

32.remove invalid parentheses

33.swap nodes in pairs(linkedlist)
这道题也是linkedlist的经典题目，关于节点交换的题目都需要知道要交换的点的前一个节点，有些需要知道交换节点的后一个节点。这道题的难点在于要想到每两个交换的节点都是在变化的，所以我们申明指针指向这两个节点和他们的前节点的时候需要在循环中。
public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        ListNode point = dummy;
        dummy.next = head;
       
        while(head!=null && head.next!=null){
            ListNode p1 = head;
            ListNode p2 = head.next;
            point.next = p2;
            p1.next = p2.next;
            p2.next = p1;
            
            point = head;
            head = head.next;
        }
        
        return dummy.next;
    }

34.search in rotated sorted array(binary tree)

35.zigzag conversion(string)
按照一定规律排列读取string,就是将规律装换成数学表达式。这道题有几个注意的点，第一个是因为最后字符串的读取是换了一个方式，所以我们需要新建一个stringbuilder，将字符串读取添加。第二个问题就是字符读取过程是一个反复的过程，向下到低端就要反弹回去，所以要使用两个循环，一个是向下循环，一个是向上循环。
public String convert(String s, int numRows) {
        char[] array = s.toCharArray();
        int len = array.length;
        
        StringBuilder []sb = new StringBuilder[numRows];
        for(int i=0;i<numRows;i++){
            sb[i] = new StringBuilder();
        }
        
        int i = 0;
        while(i<len){
            for(int index = 0;index<numRows && i<len;index++){
                sb[index].append(array[i++]);
            }
            for(int index = numRows-2;index>=1 && i<len;index--){
                sb[index].append(array[i++]);
            }
        }
        for(int index=1;index<numRows;index++){
            sb[0].append(sb[index]);
        }
        
        return sb[0].toString();
    }

36.string to integer(atoi)
这题就是需要考虑全面一点，是否在integer的范围里面，小数怎么办，非法字符怎么办,string是null怎么办,还要考虑这个数字是不是负数，string当中的空格怎么办。
trim()是把起始和结尾的空格都删除了。首先就应该将前后的空格删除，然后判断当前的第一个字符是什么符号，并做好标记。逐个判断是否为数字，如果是的话就加进去。数字的读取 sum = sum *10+str.charAt(i)-‘0’;因为要判断数字是否超出了整数的表示范围，所以我们需要将和设置为long,再根据符号判断是否超出上界还是下界。要注意的是如果是负数，和是要乘以（-1）的。
public int myAtoi(String str) {
        if(str==null || str.length()==0) 
            return 0;
        str = str.trim();
        
        int signal = 1,len = str.length(),start = 0;
        long sum = 0;
        if(str.charAt(0)=='+'){
            signal = 1;
            start++;
        }else if(str.charAt(0)=='-'){
            signal = -1;
            start++;
        }
        
        for(int i=start;i<len;i++){
            if(!Character.isDigit(str.charAt(i))){
                return (int)sum * signal;
            }
            sum = sum*10+str.charAt(i)-'0';
            if(signal==1 && sum>Integer.MAX_VALUE){
                return Integer.MAX_VALUE;
            }
            if(signal==-1 && (-1) * sum<Integer.MIN_VALUE){
                return Integer.MIN_VALUE;
            }
        }
        return (int)sum*signal;
    }

37.container with most water
这道题一开始我理解错了题意，两条垂直的线分别代表的是两个高度，要盛水的话肯定是按短的算，并不是计算两根线和x轴组成的图形的面积。这道题可以用双指针的思想来解决，分别从头和尾开始向中间进发。因为end-start无论是左边往右走还是右边往左走都是减少的，所以不可以不用考虑。但是高度都是短的提取，所以都是要紧着短的来，目的是为了找到更短的。
public int maxArea(int[] height) {
        
        int max = Integer.MIN_VALUE;
        int start = 0;
        int end = height.length-1;
        
        while(start<end){
            max = Math.max(max,Math.min(height[start],height[end])*(end-start));
            if(height[start]>height[end]){
                end--;
            }else start++;
        }
        return max;
    }

38.remove nth node from end of list
这道题和之前删除结点的题目一样都是需要找到要删除结点的前一个结点。但是这样的题目有一个问题就是考虑的问题比较多，最大的问题就是空指针的问题，也就是寻路指针在遍历的时候他自己和next指针是不是为空都是需要进行判断的，要不然就会出错。
 public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null || n==0){
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        ListNode point = dummy;
        
        for(int i=0;i<n;i++){
            head = head.next;
            if(head==null){
                return null;
            }
        }
        
        while(head!=null && head.next!=null){
            head = head.next;
            point = point.next;
        }
        
        point.next = point.next.next;
        return dummy.next;
    }

39.generate parentheses
这道题我一开始的想法是，建立一个stack来判断是否所有的括号都是配对的，然后使用dfs的方法来生成最后的答案。但是在操作过程中我发现我把问题复杂了，还有一个问题是我们不好直接构建原始数组使其包含所有的左括号和右括号。
这道题毫无疑问是使用dfs的方法来解决，但是解决的方法其实就是按照题目的意思来构造list就行了，定义一个左括号的下标，一个右括号的下标，当str的数量满足n*2的时候就放到list中，如果open<n小就应该加上一个左括号，如果close<open就加上一个右括号。
 public List<String> generateParenthesis(int n) {
        List<String> results = new ArrayList<String>();
        helper(results,"",0,0,n);
        return results;
    }
    
    private void helper(List<String> results, String str, int open, int  close, int max){
       if(str.length() == max*2){
           results.add(str);
           return;
       }
       if(open<max){
           helper(results,str+"(",open+1,close,max);
       }
       if(close<open){
           helper(results,str+")",open,close+1,max);
       }
    }

40.combination sum

41.combination
这道题是求1到n个数，每次只去其中的k个数，求combination。也是一道dfs的题目，跳出的条件就是com.size()==k,只是取数的范围是1到n，不是从0开始取。
public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> results = new ArrayList<>();
        
        helper(results,new ArrayList<Integer>(),n,k,1);
        return results;
    }
    
    private void helper(List<List<Integer>> results, List<Integer> com, int n,int k, int startindex){
        if(com.size()==k){
            results.add(new ArrayList<Integer>(com));
            return;
        }
        
        for(int i=startindex;i<=n;i++){
            com.add(i);
            helper(results,com,n,k,i+1);
            com.remove(com.size()-1);
        }
    }

42. combination sum ii
43. factor combinations	
这道题其实也是dfs的应用，其实就是回溯法，一开始我们就可以像计算和一样，每一次将应该放入的数字放进list中，然后target就变成target/i,结果中我们需要进行判断，当target为1的时候表示结束了但是有一种情况，就是这个数自己，所以我们需要在判断中再加一个判断，就是com中是否有数字，如果有就把数放进results。
public List<List<Integer>> getFactors(int n) {
        
        List<List<Integer>> results = new ArrayList<>();
        helper(results,new ArrayList<Integer>(),2,n);
        return results;
    }
    
    private void helper(List<List<Integer>> results, List<Integer> com, int startindex, int n){
        if(n==1){
            if(com.size()>1){
                results.add(new ArrayList<Integer>(com));
                return;
            }
        }
        
        for(int i=startindex;i<=n;i++){
            if(n%i==0){
                com.add(i);
                helper(results,com,i,n/i);
                com.remove(com.size()-1);
            }
        }
    }

44.valid triangle number
这道题可以使用双指针来解决。有点像三个数的和那道题，确定一个值，然后另外两个值变化。我们一开始将数组进行排序，确定一个最大值，然后确定最大值的位置-1为右边的点，0为左边的点，因为三角形有效的判断条件是较小的两条边之和大于第三边，所以如果左右两点的和大于最大值，则表明这两个点中间的点都是合格的点，也就是说count+=right+left。然后right—.如果不是的话就是left++.
public int triangleNumber(int[] nums) {
        Arrays.sort(nums);
        
        int count = 0;
        for(int i=nums.length-1;i>=0;i--){
            int left = 0;
            int right = i-1;
            while(left<right){
                if(nums[left]+nums[right]>nums[i]){
                    count += right-left;
                    right--;
                }else{
                    left++;
                }
            }
        }
        return count;
    }

45.sort colors
首先想到的是分别统计三种颜色各有多少个，然后在他们相应的位置放上他们相应的值，稍微优化一下发现只要统计其中两个颜色的个数就可以了。
public void sortColors(int[] nums) {
        int redcnt = 0;
        int whitecnt = 0;
        
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0) redcnt++;
            if(nums[i]==1) whitecnt++;
            
        }
        for(int i=0;i<nums.length;i++){
            if(i<redcnt) nums[i]=0;
            if(i>=redcnt&&i<whitecnt+redcnt) nums[i]=1;
            if(i>=whitecnt+redcnt&&i<nums.length) nums[i]=2;
        }
        
    }

这是遍历了两遍，如何遍历一遍就能解决问题呢？受到上面的优化的启发，如果我们直接把2放到最右边，把0放到最左边，那么剩下来的1就应该被放在了他应该在的位置上。
public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1;
        int i = 0;
        while(i <= right){
            // 遇到0交换到前面
            if(nums[i] == 0){
                swap(nums, i, left);
                left++;
                // 因为左边必定有序，所以可以直接i++
                i++;
            // 遇到2交换到后面
            } else if(nums[i] == 2){
                swap(nums, i, right);
                right--;
            } else {
            // 遇到1跳过 
                i++;
            }
        }
    }
    
    private void swap(int[] nums, int i1, int i2){
        int tmp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = tmp;
    }
要注意一点，循环的判断条件是i<=right,不是i<nums.length。

46.subsets 
public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums.length==0 || nums==null){
            return new ArrayList<>();
        }
        
        dfs(nums,0,results,new ArrayList<Integer>());
        return results;
    }
    
    private void dfs(int[] nums, int startindex, List<List<Integer>> results, List<Integer> sub){
        results.add(new ArrayList<Integer>(sub));
        
        for(int i = startindex;i<nums.length;i++){
            sub.add(nums[i]);
            dfs(nums,i+1,results,sub);
            sub.remove(sub.size()-1);
        }
    }

47.subsets ii
这道题相较于上一道题就是要考虑duplicates。就是在放入sub之前要对连续的两个数进行比较，只有不相等才放进去。
 public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums==null || nums.length==0){
            return results;
        }
        Arrays.sort(nums);
        helper(results,new ArrayList<Integer>(),0,nums);
        return results;
    }
    private void helper(List<List<Integer>> results, List<Integer> sub, int startindex, int[]nums){
         results.add(new ArrayList<Integer>(sub));
        
         for(int i=startindex;i<nums.length;i++){
             if (i != startindex && nums[i]==nums[i-1]) {
                continue;
            }
             sub.add(nums[i]);
             helper(results,sub,i+1,nums);
             sub.remove(sub.size()-1);
         }
    }

48.search insert position
因为题目中写清楚了是sorted array，而且是找元素，所以很自然想到了使用binary tree.这道题只要注意超过最大值的位置是nums.length,以及最后的返回值是end就可以了。
public int searchInsert(int[] nums, int target) {
        if(target>nums[nums.length-1]) return nums.length;
        if(target<nums[0]) return 0;
        int start = 0;
        int end = nums.length-1;
        while(start+1<end){
            int mid = start+(end-start)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                end = mid;
            }else start = mid;
        }
        if(nums[start]==target) return start;
        if(nums[end]==target) return end;
        
        return end;
    }

49.binary tree inorder traversal
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> results = new ArrayList<Integer>();
        helper(root,results);
        return results;
    }
    private void helper(TreeNode root,List<Integer> results){
        if(root==null) return;
        helper(root.left,results);
        results.add(root.val);
        helper(root.right,results);
    }

50. valid number
这道题的描述就十分的抽象，只是判断一个字符串是不是valid number,是哪一类的数，int,float都不知道，是正是负不知道，如果是小数，采取什么样的表示方式也不知道，所以这道题只能列举出所有的可能性再针对每一个可能性进行判断。
1.空格的问题。可以通过trim来去除开头和结尾的空格，中间的空格则直接判定为无效
2.小数点。位置随意，但是不同位置的限制条件不同。首先只能出现一次，不能出现在e的后面，出现在末尾前面只能是数字。
3.e/E.不能出现在开头和结尾，并且两遍都要有数字，自然数前面不能是符号
4.符号。可以在开头，可以在e之后，但是不能是最后一个数字。
public boolean isNumber(String s) {
        if(s==null) return false;
        s = s.trim().toLowerCase();   //e and E all become e
        if(s.length()==0) return false;
        
        
        boolean hasNum = false;
        boolean hasE = false;
        boolean hasDot = false;
        int signal = 0;
        int n = s.length();
        for(int i=0;i<n;i++){
            char c = s.charAt(i);
            if(!isValid(c)){
                return false;
            }
            if(c>='0'&&c<='9'){
                hasNum = true;
            }
            if(c=='.'){
                if(hasE||hasDot){
                    return false;
                }
                if(i==n-1&&!hasNum){
                    return false;
                }
                hasDot = true;
            }
            if(c=='e'){
                if(hasE||!hasNum){
                    return false;
                }
                if(i==n-1){
                    return false;
                }
                hasE = true;
            }
            if(c=='+'||c=='-'){
                if(signal==2){
                    return false;
                }
                if(i==n-1){
                    return false;
                }
                if(i>0&&s.charAt(i-1)!='e'){   //如果前面不是e那就是false
                    return false;
                }
                signal++;
            }
        }
        return true;
    }
    
    private boolean isValid(char c){
        if(c=='+'||c=='-'||c>='0'&&c<='9'||c=='e'||c=='.'){
            return true;
        }else return false;
    }

51.decode ways(dp)
和爬楼梯合起来看，整道题最麻烦的就是要判断0在的位置。首先构建出dp数组，dp[i]表示字符串0到i-1这段数组中的解码方式数量，最麻烦的是dp[0]=1,这个初始化要注意。然后就是判断字符串i-1到i是不是能用两个字符位表示，能就判断int值是不是在10-26之间，不是的话就dp[i]=dp[i-1];
public int numDecodings(String s) {
        if (s.isEmpty() || (s.length() > 1 && s.charAt(0) == '0')) return 0;
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        for (int i = 1; i < dp.length; ++i) {
            dp[i] = (s.charAt(i - 1) == '0') ? 0 : dp[i - 1];
            if (i > 1 && (s.charAt(i - 2) == '1' || (s.charAt(i - 2) == '2' && s.charAt(i - 1) <= '6'))) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[s.length()];
    }

52.climbing stairs(dp)
从后往前考虑，如果最后是1步，那么就是dp[i-1],如果是2步，那么就是dp[i-2].dp[i]就是表示i层楼梯有多少种方法爬。
public int climbStairs(int n) {
        if(n<=1){
          return 1;  
        } 
        int [] results = new int[n+1];
        results[0] = 1;
        results[1] = 1;
        for(int i=2;i<=n;i++){
            results[i] = results[i-1] + results[i-2];    
        }
        return results[n];
    }

53.gray code
gray code的书写规则是从0开始，然后改变最右边的数，然后改变从最右边数第一个1的左边的数。以此类推。
当i=k是，前半部分的gray code 和 i=k-1是一样的，只是高位补0.后半部分的值是前半部分的值从后往前依次加上2^(i-1)。
public List<Integer> grayCode(int n) {
       List<Integer> result = new ArrayList<Integer>();      
       result.add(0);  
      for(int i=0; i< n; i++)  
     {  
        int highestBit = 1<<i;  
        int len = result.size();  
        for(int j = len-1; j>=0; j--)  
        {  
          result.add(highestBit + result.get(j));  
        }  
      }  
      return result;  
    }

54.partition list
不需要把问题想得太复杂，我已开始就假定要有三个list，一个总结果，一个小于给定值 ，一个大于给定值。其实只要两个，最后判断完将小于的最后一个指针指向大于给定值的dummy结点的next就行，返回小于给定值的dummy.next.在循环中嵌套判断语句，可以将判断语句中重复的语句提取出来。
public ListNode partition(ListNode head, int x) {
       
        ListNode moreList = new ListNode(0);
        ListNode lessList = new ListNode(0);
        ListNode more = moreList;
        ListNode less = lessList;
        if(head==null){
            return head;
        }
        
        while(head!=null){
            if(head.val>=x){
                more.next = head;
                more = more.next;
            }else{
                less.next = head;
                less = less.next;
            }
             head = head.next;
        }
        
        more.next = null;
        less.next = moreList.next;
        
        return lessList.next;
    }

55.remove duplicates from sorted list
这题相较于第二题就是少了一个判断第一个数和第二个数是否相等这个条件，只需要pre和cur两个指针进行判断是否相等的情况就可以了。
public ListNode deleteDuplicates(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head;
        ListNode pre = dummy;
        while(cur!=null){
            while(cur.next!=null && cur.val == cur.next.val){
                cur = cur.next;
            }
            
            pre.next = cur;
            pre  = cur;
            cur = cur.next;
        }
        
        return dummy.next;
    }

56.remove duplicates from sorted list ii
这道题的意思是只要发现了重复的数字就把list中所有的包含这个数的结点删除，我已开始的想法是用到了三个指针，一个是pre，指向第一个重复数字的前面，第二个指向第一个开始重复的数字，最后一个指向最后一个重复的数字，但是发现不仅代码量大，而且中间需要判断是否为空的情况太多。细细想想其实不需要那么多指针。我不是用head!=null作为循环判断条件是因为在操作过程中有时候需要往后走超过一个结点的长度，如果用head = head.next来计算就会出错。一个比较tricky的情况就是第一个数字和第二个数字是否重复，如果不加以判断就会出现如果第一个数字和第二个数字不相等，就会在结果的时候直接跳过了第一个数。
public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next==null) return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            while(cur.next!=null && cur.val == cur.next.val){
                cur = cur.next;
            }
            if(pre.next == cur){
                pre = cur;
            }else{
                pre.next = cur.next;
            }
            cur = cur.next;
        }
        return dummy.next;
    }

57. remove duplicates from sorted array ii
这道题要是利用题目中已经排序好这一个条件会非常好做，因为我们知道排好序了，并且最多就是只有两个数，也就是说刚开始的两个数肯定会放进去，换言之也就是肯定会从第三个位置，下标为2的位置开始插入，判断是否插入这个位置的条件就是当前取出的数字是不是比num[i-2]大，这很好理解，如果前两个是一样，则第三个数不同插入，前两个不一样也是这个结果。
 public int removeDuplicates(int[] nums) {
        int i = 0;
        for (int n : nums) 
             if (i <  2 || n > nums[i - 2])
                 nums[i++] = n; 

        return i;
    }

58.find peak element
这是一道binary tree的问题。我们取中间的数，当这个点满足条件，也就是大于左边也大于右边就return这个点的index.如果这个点比左边的小，就说明在左边的点的左边区域肯定有一个点满足条件，相反就是在右边。
public int findPeakElement(int[] nums) {
        if(nums==null || nums.length==0){
            return -1;
        }
        int start = 0;
        int end = nums.length-1;
        while(start+1<end){
            int mid = start+(end-start)/2;
            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){
                return mid;
            }else if(nums[mid]<nums[mid-1]){
                end = mid;
            }else start = mid;
        }
        if(nums[start]>nums[end]) return start;
        else return end;
    }

59.find the celebrity
如果A认识B，那么B有可能是名人，A肯定不是名人，所以我们第一次遍历可以找到一个疑似名人的候选人，第二次遍历的时候可以对这个候选人进行判断，首先自己等于自己继续循环，不能就要看他自己不能认识别人，别人必须认识自己，如果两者有一个不满足就直接返回-1，如果都满足则输出位置。
public int findCelebrity(int n) {
        if(n<=1) return n;
        int candidate = 0;
        for(int i = 1;i<n;i++){
            if(!knows(i,candidate)){
                candidate = i;
            }
        }
        
        for(int j = 0;j<n;j++){
            if(j==candidate) continue;
            if(!knows(j,candidate)||knows(candidate,j)){
                return -1;
            }
        }
        return candidate;
    }

60.find the duplicate number
这道题有几个限制条件，如果少了一个constant extra space可以用数组解答，总共用n个数，那就生成一个长度为n的数组，但是有n+1个位置，肯定有一个位置的值大于1，找到就可以了。
public int findDuplicate(int[] nums) {
        int len = nums.length;
        int result = 0;
        int[] array = new int[len];
        for(int i=0;i<len;i++){
            array[nums[i]]++;
        }
        
        for(int i=0;i<array.length;i++){
            if(array[i]>1){
                result = i;
            }
        }
        return result;
        
    }
如果能对原数组进行修改，我们可以进行排序，然后查找。如果constant extra space，我想到了位运算的异或,但是两个相同的数的异或为0，不方便确定哪一个数开始为0，所以pass。网上一个人的解法是将题目转化成链表问题，查找从哪个点开始循环的。
public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        // 找到快慢指针相遇的地方
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);
        int find = 0;
        // 用一个新指针从头开始，直到和慢指针相遇
        while(find != slow){
            slow = nums[slow];
            find = nums[find];
        }
        return find;
    }

61.linked list cycle
可以转换成追逐问题，也就是快慢指针。如果慢的指针能够追上快的指针则表示有环。
 public boolean hasCycle(ListNode head) {
        if(head==null || head.next==null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast!=slow){
            slow = slow.next;
            if(fast==null||fast.next==null){
                return false;
            }
            fast = fast.next.next;
            
        }
        return true;
    }
62.linked list cycle ii
 public ListNode detectCycle(ListNode head) {
        if(head==null || head.next==null) return null;
        ListNode node = chase(head);
        if(node == null) return null;
        
        while(node.next!=head){
            head = head.next;
            node  =node.next;
        }
        return head;
    }
    
    private ListNode chase(ListNode head){
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast!=slow){
            slow = slow.next;
            if(fast==null || fast.next==null){
                return null;
            }
            fast = fast.next.next;
        }
        return slow;
    }

63.Intersection of Two Linked Lists
这道题就是计算两个节点有没有重合，我们并不能直接比较节点是否相等，因为肯定不等，因为他们在内存中的位置不等。所以只能比较指向同一个节点的两个指针里面的值是否相等。为了方便我们让两个list等长。
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null || headB==null) return null;
        int cntHeadA = 0;
        int cntHeadB = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a!=null){
            cntHeadA++;
            a = a.next;
        }
        while(b != null){
            cntHeadB++;
            b = b.next;
        }
        if(cntHeadA > cntHeadB){
            int diff = cntHeadA - cntHeadB;
            for(int i=0;i<diff;i++){
                headA = headA.next;
            }
        }else{
            int diff = cntHeadB - cntHeadA;
            for(int i=0;i<diff;i++){
                headB = headB.next;
            }
        }
        ListNode result = null;
        while(headA!=null){
            if(headA.val == headB.val){
                result =  headA;
                break;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }
        return result;
    }

64.median of two sorted arrays
有点难，第一遍没有看懂代码。
public double findMedianSortedArrays(int A[], int B[]) {
        int m = A.length;
        int n = B.length;
        int total = m + n;
        if(total % 2 == 0){
            return (getMedian(A, 0, m-1, B, 0, n-1, total/2) + getMedian(A, 0, m-1, B, 0, n-1, total/2+1))/2;
        }
        else{
            return getMedian(A, 0, m-1, B, 0, n-1, total/2+1);
        }
         
    }
     
    public static double getMedian(int[] A, int astart, int aend, int[] B, int bstart, int bend, int k){
        int m = aend - astart + 1;
        int n = bend - bstart + 1;
         
        if(m > n){   //保证b是小的那个数组
            return getMedian(B, bstart, bend, A, astart, aend, k);
        }
        if(m == 0){
            return B[k-1];
        }
        if(k == 1){
            return Math.min(A[astart], B[bstart]);
        }
         
        int a = Math.min(k/2, m);
        int b = k - a;
        if(A[astart + a - 1] < B[bstart + b -1]){
            return getMedian(A, astart + a, aend, B, bstart, bend, k-a);
        }
        else if(A[astart + a - 1] > B[bstart + b -1]){
            return getMedian(A, astart, aend, B, bstart + b, bend, k-b);
        }
        else{
            return A[astart + a -1];
        }
    }

65.Kth Largest element in an array
像这种找第几大第几小的问题我们会想到如果这个数组是排好序的就是非常简单来做，但是因为无序我们就想办法让他有序，所以我们想到了priority queue来存储数据，数据按照降序排列，大于k就Poll,最后return pq.poll();
 public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer a,Integer b){
                return a-b;
            }
        });
        for(int i=0;i<nums.length;i++){
            pq.offer(nums[i]);
            if(pq.size()>k){
                pq.poll();
            }
        }
        return pq.poll();
    }

66.reverse string
这题比较tricky的方法就是使用string builder的reverse方法，当然还是可以使用toCharArray方法来实现，但是要注意循环判断的范围，是s.length()/2并不是s.length(),因为如果是全部的话，前面交换过的字符又会被交换回来。
public String reverseString(String s) {
        // StringBuilder sb = new StringBuilder(s);
        // return sb.reverse().toString();
        
        char [] array = s.toCharArray();
        for(int i=0;i<array.length/2;i++){
            char a  = array[array.length-1-i];
            array[array.length-1-i] = array[i];
            array[i] = a;
        }
        return String.valueOf(array);
    }

67.reverse string ii
这里是转换2k个字符串中的前k个，我们在做涉及到字符的问题的时候自己就要问自己要不要考虑到大小写的问题。这道题只要按照题目的意思逐个情况进行判断就可以了，难点就只有取子字符串的时候下标的问题，也就是边界的问题需要注意。
public String reverseStr(String s, int k) {
        int len = s.length();
        StringBuilder results = new StringBuilder();
        int index = 0;
        while(len>=2*k){
            String sub = s.substring(index,index+k);
            sub = reverseK(sub);
            results.append(sub);
            results.append(s.substring(index+k,index+2*k));
            index += 2*k;
            len -= 2*k;
        }
        if(len<2*k && len>=k){
            results.append(reverseK(s.substring(index,index+k)));
            results.append(s.substring(index+k,index+len));
        }
        if(len<k){
            results.append(reverseK(s.substring(index,index+len)));
        }
        return results.toString();
    }
    
    private String reverseK(String s){
        StringBuilder sb = new StringBuilder(s);
        return sb.reverse().toString();
    }

68.reverse words in a string
这道题的意思是将给定的字符串中的单词reverse一下，也就是说hello world,返回的应该是world hello.因为有先进后出这样的特征所以我想到了用stack来做。这道题有一个重点就是判断条件不能是等于” ”,要是不能equals“”，要不然就会出错。不能使用==来判断。
public String reverseWords(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        String[] array = s.split(" ");
        StringBuilder sb = new StringBuilder();

        for (int i = array.length - 1; i >= 0; --i) {
            if (!array[i].equals("")) {
                sb.append(array[i]).append(" ");
            }
        }

        //remove the last " "
        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);
    }

69.reverse words in a string ii
这道题是不能使用extra space，也就是要在给定的数组中进行操作，那么就不能使用什么string数组了。这时候就想到了rotate array的做法，进行两部分的reverse。但是要注意结束条件有两个，一个是遇到空格，另一个是遍历的变量等于str.length-1。
public void reverseWords(char[] str) {
        if(str==null || str.length==0){
            return;
        }
        int index = 0;
        for(int i=0;i<str.length;i++){
            if(str[i]==' '){
                reverseW(str,index,i-1);
                index = i+1;
            }
            if(i==str.length-1){
                reverseW(str,index,i);
            }
        }
        reverseW(str,0,str.length-1);
    }
    
    private void reverseW(char[] str, int start,int end){
        while(start<end){
            char temp = str[end];
            str[end] = str[start];
            str[start] = temp;
            start++;
            end--;
        }
    }

70.reverse words in a string iii
这道题要求将每一个单词进行reverse，这就容易想到用stack来存储。只是需要考虑到只有一个单词的情况。
public String reverseWords(String s) {
        if(s.length()==0||s==null){
            return s;
        }
        Stack<Character> stack = new Stack<Character>();
        StringBuilder sb = new StringBuilder();
        s = s.trim();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=' '){
                stack.push(s.charAt(i));
            }else{
                while(stack.size()!=0){
                   sb.append(stack.pop()); 
                }
                sb.append(' ');
            }
        }
        while(stack.size()!=0){
            sb.append(stack.pop());
        }
        
        return sb.toString();
    }

71.sort list

72.intersection of two arrays 
因为只是将出现的共同部分的其中一个放进最后的数组中，所以我想到了使用hashset来存储数据。有几个问题需要注意，就是最后的结果的数组的大小要是正好的，不能有空余空间。hashset.iterator遍历返回的是对象，要进行类型转换。
 public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> hs = new HashSet<Integer>();
        if(nums1==null || nums2==null || nums1.length==0 || nums2.length==0){
            return new int[0];
        }
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        
        int index1 = 0;
        int index2 = 0;
        while(index1<nums1.length && index2<nums2.length){
            if(nums1[index1]==nums2[index2]){
                hs.add(nums1[index1]);
                index1++;
                index2++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else index1++;
        }
        
        Iterator itr = hs.iterator();
        int[] results = new int[hs.size()];
        int index = 0;
        while(itr.hasNext()){
            results[index++] = (int)itr.next();
        }
        
        return results;
    }
73. Intersection of two arrays ii
和上一题相比就是将所有的相同的数据放进结果数组中，所以只要将存储的数据结构从hashset变成arraylist就好了。
public int[] intersect(int[] nums1, int[] nums2) {
       if(nums1==null || nums2==null || nums1.length==0 || nums2.length==0){
           return new int[0];
       }
        
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        
        int index1 = 0;
        int index2 = 0;
        int index = 0;
       ArrayList<Integer> al = new ArrayList<Integer>();
        while(index1<nums1.length && index2<nums2.length){
            if(nums1[index1]==nums2[index2]){
                al.add(nums1[index1]);
                index1++;
                index2++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else{
                index1++;
            }
        }
        int[] results = new int[al.size()];
        for(int i=0;i<results.length;i++){
            results[i] = al.get(i);
        }
        
        return results;
    }

74.valid sudoku
一个有效的数独需要满足几个条件，行和列还有一个3X3的正方形中的数字要在1-9之间，或者为空。所以我们构建一个boolean[] visited = new boolean[9];用来表示九个数字有没有被访问过。因此我们只需要对行，列和九宫格进行判断就可以了。
public boolean isValidSudoku(char[][] board) {
        boolean[] visited = new boolean[9];
        
        for(int i=0;i<9;i++){
            Arrays.fill(visited,false);
            for(int j=0;j<9;j++){
                if(!process(board[i][j],visited)){
                    return false;
                }
            }
        }
        
        for(int j=0;j<9;j++){
            Arrays.fill(visited,false);
            for(int i=0;i<9;i++){
                if(!process(board[i][j],visited)){
                    return false;
                }
            }
        }
        
        for(int i=0;i<9;i+=3){
            for(int j=0;j<9;j+=3){
                Arrays.fill(visited,false);
                for(int k=0;k<9;k++){
                    if(!process(board[i+k/3][j+k%3],visited)){
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    private boolean process(char c,boolean[] visited){
        if(c=='.'){
            return true;
        }
        int num = c-'0';
        if(c<'1'||c>'9'||visited[num-1]){
            return false;
        }
        visited[num-1]=true;
        return true;
    }

75.daily temperatures
题目是：Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.

For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].

首先要注意的问题就是边界值，就是如果i在数组内，但是j一直找到了最后都没有找到比他大的数，也就是小于等于当前数怎么办。还有就是i到最后了，results[index]=0;
public int[] dailyTemperatures(int[] temperatures) {
        if(temperatures==null || temperatures.length==0){
            return new int[0];
        }
        
        int len = temperatures.length;
        int[] results = new int[len];
        
        int index = 0;
        for(int i=0;i<len;i++){
            int j=i+1;
            
            for(;j<len;j++){
                
                if(index<len && temperatures[j]>temperatures[i]){
                   results[index++] = j-i;
                   break;
               }
           }
            if(index<len&&j==len&&temperatures[len-1]<=temperatures[i]){
                results[index++]=0;
            }
            if(index<len&&j==len&&i==len-1){
                results[index]=0;
            }
        }
        return results;
    }

76. Unique paths
这道题并不是特别难想，有点像爬楼梯，但是有一点要注意的地方就是第一行和第一列的初始值为1，并不是dp[0][1]和dp[1][0]为1.因为只有一行的话就是只有一种可能性。
public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        if(m==0 || n==0){
            return 1;
        }
        for(int i=0;i<m;i++){
            dp[i][0]=1;
        }
        for(int i=0;i<n;i++){
            dp[0][i]=1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        return dp[m-1][n-1];
    }

77.unique paths ii
这道题和上一题相比多了一个障碍物的判断和抉择。在判断的时候出了点问题，如果发现有障碍，则后面都是0.状态转移方程则应该是发现障碍则方程为0，表示不通。
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid==null||obstacleGrid.length==0||obstacleGrid[0].length==0){
            return 0;
        }
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        
        int[][] dp = new int[m][n];
        for(int i=0;i<m;i++){
            if(obstacleGrid[i][0]!=1){
                dp[i][0]=1;
            }else
                break;
        }
        for(int i=0;i<n;i++){
            if(obstacleGrid[0][i]!=1){
                dp[0][i]=1;
            }else
                break;
        }
        
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        
        return dp[m-1][n-1];
    }
 78.nim game
 其实就一到脑筋急转弯的题目。
 public boolean canWinNim(int n) {
        if(n%4 == 0) return false;
        else return true;

    }
 79.delete node in a linked list
删除一个结点并不是一定要找到被删除结点的前一个节点，当然也要看题目的意思，如果题目要求不能修改结点的值，那么就只能对结点本身进行修改了。这里可以将后一个结点的值赋给前一个结点，然后前一个结点的next指针指向后一个节点的后一个结点就可以了。
public void deleteNode(ListNode node) {
        if(node==null){
            return;
        }
        node.val = node.next.val;  
        node.next = node.next.next;  
    }

80.longest absolute file path
我第一反应就是树的depth.但是题目的要求里面要求的并不是最深的目录，而是扎到最长的文件名。我们使用hashtable来存储需要使用的数据，当前的level与当前level的字符长度相对应。在遇到关于深度的问题的时候，尤其是和不同的深度的内容有关的时候可以考虑使用hashmap来建立两者的对应。
public int lengthLongestPath(String input) {
        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();
        hm.put(0,0);
        int res = 0;
        for(String s:input.split("\n")){
            int level = s.lastIndexOf("\t")+1;
            int len = s.substring(level).length();
            if(s.contains(".")){
                res = Math.max(res,hm.get(level)+len);
            }else{
                hm.put(level+1,hm.get(level)+len+1);
            }
        }
        return res;
    }

81.single number
每个数字都重复了两遍除了一个数字，一个数字和出现的频率有关当然会想到使用Hashmap来存储数字和频率之间的关系。但是我们可以使用^来判断，因为两个相同的数字异或为0，那么整个数组进行异或之后就是只剩下了那个结果。
public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        int result = nums[0];
        for(int i=1;i<nums.length;i++){
            result = result ^ nums[i];
        }
        return result;
    }

82.single number ii
利用位运算。想不起来对于数字题目怎么解，或者题目要求的时间复杂度小，可以考虑使用位运算来解答。因为每一个数字出现了三次，所以这三个数字对应的1的位置出现了三次，我们统计出他们出现的次数然后%3，这样就可以保证最后剩下的数字就是我们想要找的数字了。
public int singleNumber(int[] A) {
       int[] digits = new int[32];  
    for(int i=0;i<32;i++)  
    {  
        for(int j=0;j<A.length;j++)  
        {  
            digits[i] += (A[j]>>i)&1;  
        }  
    }  
    int res = 0;  
    for(int i=0;i<32;i++)  
    {  
        res += (digits[i]%3)<<i;  
    }  
    return res;  
        
    }

83.single number iii
因为这道题存在着两个不同的只出现一次的数字，如果我们能将这两个数分别放在不同的数组中就能够使用single number的解法了。其实解法某种程度是利用了大小的划分，将两个数进行大小的划分。我们将数组中的每个数进行一遍XOR，最后得到的数是两个不同的数的异或。我们需要找到一个值，这个值就是一个标准量将两个结果值进行划分的对比标准。因为其他的数字都是两个两个出现，所以肯定相同的数字会被划分在同一个分组里面。如何找到这个划分的数字？将number = res&(~(res-1));就是寻找从右往左寻找第一个为1的位，也就是第一个两个数不同的位。
public int[] singleNumber(int[] nums) {
        int AXORB = 0;
        for (int num : nums) {
            AXORB ^= num; 
        }
        // pick one bit as flag
        int bitFlag = (AXORB & (~ (AXORB - 1)));
        int[] res = new int[2];
        for (int num : nums) {
            if ((num & bitFlag) == 0) {        //位运算的优先级不高要注意
                res[0] ^= num;
            } else {
                res[1] ^= num;
            }
        }
        return res;
    }

84.odd even linked list
要求奇数的点在偶数的点之前。这题并不难，可以使用双指针，一个指向奇数点，一个指向偶数点，但是需要注意空指针的判断。
public ListNode oddEvenList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode point = head.next;
        ListNode Odd = head;
        ListNode Even = head.next;
        while(Odd!=null && Even !=null && Even.next!=null){
            Odd.next = Even.next;
            Odd = Odd.next;
            Even.next = Odd.next;
            Even = Even.next;
        }
        Odd.next = point;
        
       return dummy.next;
    }

85.wiggle sort
nums[0] <= nums[1] >= nums[2] <= nums[3]...
将数组先进行排序，然后将第三个数字和第二个交换，第五个和第四个交换。
public void wiggleSort(int[] nums) {
        if(nums.length==0||nums==null){
            return;
        }
        
        Arrays.sort(nums);
        for(int i=2;i<nums.length;i+=2){
            int temp = nums[i];
            nums[i] = nums[i-1];
            nums[i-1] = temp;
        }
    }

86.wiggle sort ii
(nums.length+1)>>1,其实就是找中间的位置mid。temp[i] = (i & 1) == 0 ?  nums[--s] : nums[--t] ;从中间先取值，然后最后一个值，然后mid-1，然后end-1，依次往后。(i&1)==0用以判断奇偶其实就是用以间隔执行取值语句。
public void wiggleSort(int[] nums) {
        Arrays.sort(nums);
        
        int[] temp = new int[nums.length];
        int s = (nums.length + 1) >> 1, t = nums.length;
        for (int i = 0; i < nums.length; i++) {
            temp[i] = (i & 1) == 0 ?  nums[--s] : nums[--t] ;
        }
 
        for (int i = 0; i < nums.length; i++)
            nums[i] = temp[i];
    }

87.search for a range
binary tree的经典题目。分别找开始点和结束点。
public int[] searchRange(int[] nums, int target) {
        int[] result = {-1,-1};
        if(nums.length==0 || nums==null){
            return result;
        }
        
        
        int left = 0;
        int right = 0;
        
        
        int start = 0;
        int end = nums.length-1;
        while(start+1<end){
            int mid = start + (end-start)/2;
            if(nums[mid]<target){
                start = mid;
            }else {
                end = mid;
            }
        }
        if(nums[start]==target)
            left = start;
        else if(nums[end]==target) left = end;
        else left=-1;
        
        start = 0;
        end = nums.length-1;
        while(start+1<end){
            int mid = start+(end-start)/2;
            if(nums[mid]>target){
                end = mid;
            }else{
                start  = mid;
            }
        }
        if(nums[end]==target) 
            right = end;
        else if(nums[start]==target) right = start;
        else right = -1;
        
        result[0]=left;
        result[1]=right;
        return result;
    }

88.palindrome permutation
要抓住palindrome的特征，如果每个字符都是出现偶数次数则肯定是，如果只有一个字符出现奇数次也肯定是。
public boolean canPermutePalindrome(String s) {
        int[] results = new int[256];
        if(s==null||s.length()==0){
            return false;
        }
        for(int i=0;i<s.length();i++){
            results[s.charAt(i)]++;
        }
        boolean hasOdd = false;
        for(int i=0;i<results.length;i++){
            if(results[i]%2!=0){
                if(!hasOdd){
                    hasOdd = true;
                }else{
                    return false;
                }
            }
        }
        return true;
    }

89.permutations ii
对应着19题一起看。相对于19题来说数字是可能出现duplicates的。我们可以使用一个visited数组来记录数组中的数是不是已经被访问了。
public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums==null){
            return results;
        }
        if(nums.length==0){
            results.add(new ArrayList<Integer>());
            return results;
        }
        Arrays.sort(nums);
        List<Integer> permutation = new ArrayList<Integer>();
        int[] visited = new int[nums.length];
        for ( int i = 0; i < visited.length; i++){
            visited[i] = 0;
        }
        helper(results,permutation,nums,visited);
        return results;
    }
    
    private void helper(List<List<Integer>> results, List<Integer> permutation, int[]nums, int [] visited){
        if(permutation.size()==nums.length){
            results.add(new ArrayList<Integer>(permutation));
            return;
        }
        
        for(int i=0;i<nums.length;i++){
            if ( visited[i] == 1 || ( i != 0 && nums[i] == nums[i - 1]
            && visited[i-1] == 0)){
                continue;
            }
            visited[i]=1;
            permutation.add(nums[i]);
            helper(results,permutation,nums,visited);
            permutation.remove(permutation.size()-1);
            visited[i]=0;
        }
    }

90.majority element
思路一：利用java的特性，使用Collections.sort()对arraylist进行排序，只需要取出最中间的数就行了，因为题目说明了肯定存在。
思路二：对arraylist进行遍历，如果下一个数和上一个数是相同的，计数器加一。利用的原理就是如果一个数出现的次数高于其他的数字的话，那么最后赋值的一定是那个majority number.
public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        int start = 0;
        int end = nums.length-1;
        int mid = start+(end-start)/2;
        return nums[mid];
    }
91.majority element ii
思路一：使用hashmap，将arraylist中的数和这个数出现的次数存放在hashmap中，然后比较他们的次数取最大值。只要题目中确定有且只有一个这样的值，这个方法都适用。majority number iii就是一个例子。

92.majority element iii

93.lonely pixel i
建立两个数组分别计算行和列中的b的数量，第一遍扫描就是统计数量，第二遍扫描的时候进行判断，如果发现了picture[i][j]==‘B’，判断这一行这一列是不是等于1，是就意味着一个满足的点。
public int findLonelyPixel(char[][] picture) {
        if(picture==null || picture.length==0 || picture[0].length==0){
            return 0;
        }
        
        int col = picture.length;
        int row = picture[0].length;
        int[] colN = new int[col];
        int[] rowN = new int[row];
        int count = 0;
        
        Arrays.fill(colN,0);
        Arrays.fill(rowN,0);
        
        for(int i=0;i<col;i++){
            for(int j=0;j<row;j++){
               if(picture[i][j]=='B'){
                   colN[i]++;
                   rowN[j]++;
               }
            }
        }
        
        for(int i=0;i<col;i++){
            for(int j=0;j<row;j++){
                if(picture[i][j]=='B'){
                    if(colN[i]==1&&rowN[j]==1){
                    count++;
                    }
                }   
            }
        }
        return count;
    }

94.lonely pixel ii（再看一遍）
这道题比上一题麻烦的是还要进行判断有b的行中出现的位置要相同。
public int findBlackPixel(char[][] picture, int N) {
        if(picture==null || picture.length==0 || picture[0].length==0){
            return 0;
        }
        
        int count = 0;
        int[] row = new int[picture.length];
        int[] col = new int[picture[0].length];
        boolean[][] visited = new boolean[picture.length][picture[0].length];
        
        for(int i=0;i<picture.length;i++){
            for(int j=0;j<picture[0].length;j++){
                visited[i][j]=false;
            }
        }
        for(int i=0;i<picture.length;i++){
            for(int j=0;j<picture[0].length;j++){
                if(picture[i][j]=='B'){
                    row[i]++;
                    col[j]++;
                    visited[i][j]=true;
                }
            }
        }
        
       for(int i=0;i<picture.length;i++){
            for(int j=0;j<picture[0].length;j++){
                if (picture[i][j] == 'B' && row[i] == N && col[j] == N) {  
                    String iStr = String.valueOf(picture[i]);  
                    int kCount = 0;  
                    for (int k = 0; k < picture.length; k++) {  
                        if (i != k && picture[k][j] == 'B') {  
                            String kStr = String.valueOf(picture[k]);  
                            if (!iStr.equals(kStr)) break;  
                            else kCount++;  
                        }  
                    }  
                    if (kCount == N-1) count++;  
                }  
            }
       }
        return count;
    }

95.find pivot index
这题其实不难，是我想复杂了。我开始想通过binary tree做，结果发现不行，第一他并没有顺序，第二如果全是负数就会出错。这道题就按照题意去做就行了。先求出所有数字的和，然后用和减去当前的数字，如果是当前的和的两倍就直接弹出，因为是从左往右，找到就弹出肯定是最左边的。如果没找到就继续往右寻找。
public int pivotIndex(int[] nums) {
        if(nums.length==0||nums==null){
            return -1;
        }
        int  sum = 0;
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
        }
        int curSum = 0;
        for(int i=0;i<nums.length;i++){
            if(sum-nums[i] == curSum *2){
                return i;
            }
            curSum += nums[i];
        }
        return -1;
    }

96.