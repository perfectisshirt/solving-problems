LinkedList:
1.reverse nodes in k-group（再做一遍）
first version:  reverse every k nodes,find the kth node then reverse them. the important thing is to how to connect them.
second version:第二遍做的时候不知道如何让k个结点依次往右平移，也就是while(true).在循环的k执行中返回值是n1并不是head.是因为每一次开始循环的时候head所在的位置就像是第一次循环时的dummy.

2. partition list（再做一遍）
first version: create two listnode, one is less than target and the other is greater or equal than target, last step is to connect two listnodes.
second version: 记得在遍历完了之后让最后一个结点的next设置为null.

3.merge two sorted array
compare two arrays' numbers one by one then get the final array.

4.merge two sorted lists
like merge two sorted array

5.reverse linkedlist ii
just part of reverse nodes in k-group, reverse a list from m to n

6.swap two nodes in linked list（再做一遍）
first version: find v1 and v2 point first and their pre nodes.但是需要考虑v1pre和v2pre的位置以及两者是否为相邻结点。如果两个节点不是相邻的，v1和v2谁在前面没有关系，但是如果两者相邻的话就需要判断谁在前面了。
second version:找到v2pre和v1pre的时候只需要对其判断是不是为Null就好，不需要对他的next判断。

7.swap nodes in pairs（再做一遍）
first version: I did not think one thing that declare listnode in while loop.当两个node需要交换并且重复进行的时候可以考虑放在while循环里，要不然就没办法迭代了。
second version: head.next!=null&&head.next.next!=null，是为了保证后面一定有两个节点，要不然会出现空指针错误。

8.rotate list(再做一遍）
first version:从首节点出发寻找从哪一个结点开始旋转，然后将旋转后的结点的next指向head，从而返回最终的链表。但是出现了TLE。
second version:使用双指针的思想，找到需要反转的第一个结点的前结点为tail，后一个结点为head,使用dummy.next连接需要反转的第一个结点，返回dummy.next即可。
third version: 只需要知道两段节点序列的最后一个结点就行了。

9.reorder list

10.reverse integer
first version:转化成字符串，然后使用字符串进行reverse。
second version: 数学计算方法，但是需要考虑到int类型的溢出问题,通常想到的方式是让结果设置为long型，然后和Integer.max_value and Integer.min_value比较。还有一种方法就是反向再比较一遍，如果结果相同则没有溢出。

11.intersection of two arrays(再做一次)
first version:首先将两个数组排序，然后依次对比其中的数字，如果相同则放到一个temp数组中，最后将temp数组中的数传递给结果数组。因为是共同的元素，所以我们设置的temp数组的大小肯定比两个数组中的任意一个都要小于等于。要注意temp数组的下标index的赋值范围，是temp[index-1]!=nums1[i];判断语句中的index==0是为了防止后面的index-1不会出现outofboundsexception.

12.intersection of two arrays ii
这题比第一题简单，并不需要判断在最后的数组中是否会出现重复的数字。

13.linkedlist cycle
设置快慢指针来判断是否有环，slow = head, fast = head.next; slow = slow.next, fast = fast.next.next;如果快指针都遍历结束了出现了null，则false,如果出现了slow==fast,返回true;

14. linked list cycle ii
这一题的难点是没办法确定开始循环的点，上一题我们只是确定了他们第一次相遇的地方，所以在上一题的基础上我们只需要再从head出发，和slow相遇就是循环开始的点。这一题特别要注意的点就是||符号，这个是按照从左往右进行判断的，所以如果先判断fast.next==null就会发生错误。从head出发到循环开始的地方和两个指针第一次相遇的点到循环开始的地方是一样长的，所以可以通过head!=slow.next来判断，最后返回head即可。

15.maximum subarray(再做一遍)
用到了动态规划的方法，kadane algorithms，假设存在A[0,i]Max[I]就是0到I的最大区间，要求要一个Max[I+1]=Max[I]+A[I+1],但是要保证这个值是大于零的。

16.majority number
思路一：利用java的特性，使用Collections.sort()对arraylist进行排序，只需要取出最中间的数就行了，因为题目说明了肯定存在。
思路二：对arraylist进行遍历，如果下一个数和上一个数是相同的，计数器加一。利用的原理就是如果一个数出现的次数高于其他的数字的话，那么最后赋值的一定是那个majority number.
17.majority number ii
思路一：使用hashmap，将arraylist中的数和这个数出现的次数存放在hashmap中，然后比较他们的次数取最大值。只要题目中确定有且只有一个这样的值，这个方法都适用。majority number iii就是一个例子。
思路二：
18.majority number iii
19.merge sorted array
利用从后往前的思想将两个数组的最后一个数字进行比较，依次向前进行比较。之所以这么做是因为题目给了提示A数组足够大。

动态规划：
我发现在做动态规划的问题的时候，非区间类的，关于求最值和可行数量的问题的时候设置数组一般的定义都是dp[i]为0到i-1表示的什么，数组的长度一般都是n+1.

1.paint fence (再做一遍)
0个fence为0，1个是k，2个fence，如果颜色一样是K,如果颜色不一样是k*(k-1),所以是k*k, 3个fence，如果前两个颜色一样，是k*(k-1),如果第三个和前面两个任意一种颜色相同且前面两个不一样颜色，则回到了第一种情况，如果三个颜色都不一样，则k*(k-1)*(k-2),最后结果是k*k*(k-1),总结来说就是新加入的这个栅栏是要比较和前面的相同还是不同，(k-1)*(same+diff).same的初始值是当只有一个fence的时候，和前一个颜色相同，但是前一个为0，所以初始值为0，diff的初始值就应该是k。

2.longest common subsequence（再做一遍）
要和substring区分开来，substring要求是要consecutive的。考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：

（1） 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；

（2） 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；

（3） 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。
设dp[i][j]，意思是A[0,i],B[0,j]中的最长相同子序列。

3.decode ways（再做一遍）
首先构建出dp数组，dp[i]表示字符串0到i-1这段数组中的解码方式数量，最麻烦的是dp[0]=1,这个初始化要注意。然后就是判断字符串i-1到i是不是能用两个字符位表示，能就判断int值是不是在10-26之间，不是的话就dp[i]=dp[i-1];

4.house robber（再做一遍）
最重要的就是判断Math.max(res[i-1], res[i-2] + A[i-1])。我们在做这道题的时候我们从递归入手慢慢的变到动态规划问题。首先我们需要知道问题是问最大值的问题，我们就会想到dp，然后我们假设是从最后一个房子开始抢，如果抢的话那么就是这间房子的价值加上index-2，或者说这间房子不抢，那么就是要抢index-1，依次递归。最后我们发现时间超过了。所以我们想到用数组来存放不断重复的数据，int []results.在我们将递推公式带入的时候发现开始值在2，那么我们就需要定义为0和1的初始值。最后我们只需要返回定义数组的最后一个值就完成了。

5.house robber ii
这题和第一题不一样的地方在这是一个圈，也就是首节点和末节点是相邻结点，这两个节点要么多不选，要么选一个。可以先按照第一个题目的方法解出来，然后分别给这几种情况比较去最大值就可以了。

6. 0,1背包问题 coin change

7. maximum subarray
有一种数学的解法，这一题刚开始做的时候出现了一个误区，发现的值如果是负数就不加，这样找到的数并不能保证是连续的。这里应该舍弃的值应该是前面的数的和为负数将其舍弃也就是赋值为0，然后从后一个数开始计算。
public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int sum = 0;
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            max = Math.max(sum,max);
            sum = Math.max(0,sum);
        }
        return max;
    }

8.climbStairs
这道题算是比较基本的动态规划的题目,但是有一个问题就是results[0]=1这个初始条件的判断，所以在进行边界条件的判断的时候我个人觉得可以将循环开始时的条件带入看初始值是否正确。
public int climbStairs(int n) {
        if(n<=1){
          return 1;  
        } 
        int [] results = new int[n+1];
        results[0] = 1;
        results[1] = 1;
        for(int i=2;i<=n;i++){
            results[i] = results[i-1] + results[i-2];    
        }
        return results[n];
    }
我发现这道题特别像斐波那契额数列，就是比斐波那契额数列少了一个第一个1.

深度搜索(DFS):
dfs的记忆存储方法一般都可以使用动态规划来解决。
1.subsets
这道题有几点要注意：首先是要判断其是不要求排好序的数组，如果需要排好序的在开始的时候就要Arrays.sort(nums).在dfs的过程中if(startindex==nums.length)因为题目中确定了[]也是其中的一个子集，所以不用加这一条判断。recursion的过程中i+1的选择，是因为不能出现重复的元素，所以要从下一个元素开始遍历。因为空集是自己的子集，所以在判断异常的时候要new 一个对象，也就是产生空集。
public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if(nums.length==0 || nums==null){
            return new ArrayList<>();
        }
        
        dfs(nums,0,results,new ArrayList<Integer>());
        return results;
    }
    
    private void dfs(int[] nums, int startindex, List<List<Integer>> results, List<Integer> sub){
        results.add(new ArrayList<Integer>(sub));
        
        for(int i = startindex;i<nums.length;i++){
            sub.add(nums[i]);
            dfs(nums,i+1,results,sub);
            sub.remove(sub.size()-1);
        }
    }

2.subsets ii
这道题和之前的题目比就是要排除重复元素，所以在dos的过程中if(startindex!=i&&nums[i]==nums[i-1]),continue.如果没有i!=startindex就会出现越界的错误。
3.split string
首先要注意题目中要求分割的字符要么一个要么两个，也就是要dfs中添加判断i<startindex+2,所以取的substring就应该是startindex,i+1.还有一个要注意的问题就是判断条件是startindex==s.length();并不是sub.size()，因为子数组的大小在for循环的时候有过判断了，i<s.length().
4.permutations
这里的就不需要startindex这个循环的标志了，因为输出的长度必须是字符串的长度，所以只需要从头到尾遍历一遍就行了。在循环的时候判断语句应该是list.contains(nums[i]),这是在回溯的时候确定判断当前的数字有没有被添加过。
5.permutations ii



tree:
1.add and search word:
trie tree的题目
2.implement trie


binary tree and divide & conquer:
1.binary tree preorder traversal:（再做一遍）
这个简单的题目有几种解法，并且都是重要的思想，第一个就是recursion，这个比较简单想到。第二是divide and conquer。还有一个就是non-recursion。和这题相似的还有ignorer and after order.他们的non-recursion都是需要背诵的。

2. binary tree maximum path sum
divide&conquer 或者 traverse 都可以做。在java里面，如果在函数中不是使用了对象进行数据传递可以使用全局变量来解决这个问题，比如int类型的数据。

3.binary tree paths
这题也可以使用两种方法，一个是traverse一个是d&c. 使用d&c的时候要注意判断如果left and right are all null, if(results.size()==0)这种情况。

4.minimum subtree
因为这道题我们需要知道的是最小子树的根结点，所以我们需要计算的值有子树的结点和还有根节点，也就是说这是一个复合的结构，我们需要构建一个新的class来存储。

5.balanced binary tree
一个数的平衡是要左子树平衡，右子树平衡同时根节点也要平衡。

6.validate binary search tree（再做一遍）
left.val<root.val<=right.val.层级遍历是一个不下降的数组，但是一个不下降的数组不一定是binary search tree, like 1,1,1. 根据定义我们知道我们只需要考虑左树，右树还有根节点这三个部分，然后将左树和右树继续划分，因此我们可以使用divide and conquer.我们在判断的时候要注意这里的left和right只是两个子树集合，因此我们只需判断left.isBST和right.isBST是不是true就可以了。

7.convert binary search tree to doubly linked list(再做一遍)
这个双链表初始化的时候一个是first开头一个是链表的结尾last,如果我们知道left是空，那么results.first = node，也就是说这时候root就作为第一个节点，相反，root就是最后一个节点。如果不是空，就进行链表的插入操作。

8.flatten binary tree to linked list（再做一遍）
根据题意走一遍就可以

9.binary search tree iterator(再做一遍)
这题基本是使用了non-recursion的方法。
 
10.in-order successor in binary search tree（再做一遍）
我的第一反应是将这个bst按照inorder构成一个双链表，然后查找出目标节点的下一个节点就行了。
还有一种方法是分情况讨论，如果要找的P点就是根节点，那么successor就是他右子树的最左边的点，如果p点在左边，也就是只要p.val<root.val，那么root=root.left,successor = root.如果在右边，root=root.right。

11.search range in binary search tree
直接的方法就是对树进行inorder traverse，然后判断当前的点是不是满足条件，满足就放到arraylist里面。因为题目要求是结果是ascending order,所以想到是inorder traverse.但是一定要注意的是在helper中要对当前的点进行判断，判断是不是null，否则会出错。 为了减少遍历次数，可以判断if(root.val>k1) helper(root.left,k1,k2).可以将arraylist 对象设置成全局变量，减少迭代变量。

12.insert node in a binary search tree
第一感觉就是找插入结点的前一个结点，然后判断要插入的结点是在左边还是右边就可以了。

13.remove node in a binary search tree（再做一遍）
整体思路应该是将找到的目标节点和他的左子树进行交换，然后一直交换将要删除的点移动到叶子节点，然后让其等于空就可以了。要注意如果要删除的结点是根节点的话，我们就需要设置一个dummy结点来防止这样的情况。并且查找结点的时候要进行结点的交换，所以不仅要找到目标节点，还需要找到这个结点的parent.

14.binary tree path sum
虽然这题是binary tree，但是看完题目的要求可以肯定是用dfs来解题。有一点需要注意的是，root.val是在recursion之前就被加进去了，因为如果在过程中会被加上很多次，结果也就是错误的。

15.binary tree path sum ii（再做一遍）
这题的难点就在于如何确定起始点和结束的点。有一种方法是从后往前进行遍历，也就是说先往list中从root开始遍历，往list中放值，但是是从最后一个数一次往前遍历，如果找到和等于target的，就从此时的i开始一直到list.size()结束放入到新的list<Integer>中，然后添加到results里面。这种方法特别的地方在于我们不知道什么是开始的点，但是随着我们遍历的深入，我们都从刚刚放入的点开始计算容易往前进行查找，因为前面的点都已经放到了list里面。

16.binary tree longest consecutive sequence（再做一遍）
我的做法是沿用了上一题的想法，从后往前找，只要前面的数比后面的数小一就把后面的数放进去，便利完再加上第一个数就可以。然后在arraylist中找出长度最长的子list，返回其长度，但是TEL错误。


bfs:
1.topological sorting（再做一遍）
定义一个array list来存放graph的结点，定义一个hash map来存放结点以及每个节点的入度。每次都选择入度为0的点作为起始点放进results,然后遍历他的邻居结点。在queue的操作中出现了问题，只要找到了一个neighbor就应该将这个点的入度减去一，然后判断入度为0的点放到results中去。

2.course schedule（再做一遍）
这一题第一个难点就是构造一个图，从一个二维数组构造一个图。List[]edges = new ArrayList[numCourses];其实这就是存储每个点的邻居节点。
for(int i=0;i<numCourse;i++){
  degrees[pre[i][0]]++;
  edges[pre[i][1]].add(pre[i][0]);
}就是将有前置结点的入度加一，将新出现的结点加到前置结点的邻居节点。

3.number of islands（再做一遍）
在矩阵中的点可以转换成坐标对象，生成做标准换数组。另外在bfs的过程中需要进行边界判断，传递的参数要是对象，因为对象的属性是两边改变的。

4.binary tree level order traversal
这是一道标准的bfs的题目。

5.search graph nodes
这也是一道标准的bfs的题目，为了避免已经判断过的点再次进行判断我们使用hashset来存储数据。

6.knight shortest path（再做一遍）
这道题遇到了一个问题就是不知道在什么地方程序跳出来，以及在满足什么条件后steps+1.这里不仅仅需要判断是不是点的坐标越界了而且还需要判断点是不是false.因为是只能往8个方向走，也就是说这8个满足条件的方向就可以认为是走了一步。

7.zombie in matrix（再做一遍）
这道题不能用和上一题完全相同的方法去解答。首先题目的意思是找到多久人类全部变成僵尸，所以我们需要设置一个变量来统计天数，同时还需要一个变量来统计人数，因为当人数为0的时候就结束判断了。我们使用queue来存放僵尸的位置。所以在使用bfs的时候需要明白我们在queue中到底存放的是什么数据。因为存放的是僵尸，所以判断是不是在边界里面的条件就应该是当前的点是不是人类。

8.graph valid tree（再做一遍）
一个valid的tree首先不能有环，也就是说edges.length!=n-1;因为是无序的，所以我们使用hashset来存储邻居节点。满足的条件就是放在hash表中的点的个数等于所有点的个数。

9.clone graph
我们使用一个hashmap来存储以前的点和现在的点，为的是让这两个点能够对应。因为graph包含点和边，所以我们除了要复制点还要复制边。

10.binary tree serialization

11.number of islands ii（再做一遍）
union-find方法。因为这道题考察的是动态的联通图。建立一个hash map,建立两个id之间的联系，初始化的时候hm.put(id,id).id = x*m+y.hashmap中第二个参数是第一个的parent，也就是第一个点的root,判断两个点是不是建立了连接就是判断这两个点的root是不是相同，如果不相同也就是说明两者不是联通的，就union，也就是father(id,id);同时islands—-。如果两者相同就是表示这两者联通。
while(fa!=father.get(fa)) {
                temp = father.get(fa);
                father.put(fa, parent) ;
                fa = temp;
            }这一步的操作的意思是因为每一步都往上递增了，所以就不再是balanced tree，所以我们需要优化他们的时间复杂度。amortized constant time complexity.

data structure:
1. hash function
2.high five
3.k closet points
4. kth largest element
5. kth largest element ii
6. top k largest numbers
7 rehashing
8.merge k sorted lists
9. ugly number
10. ugly number ii
11. strStr ii
12.flatten 2D vector
13. top k largest numbers ii
14. merge k sorted arrays
15. top k frequent words
16. heapify
17. longest consecutive sequence

数据结构题目：
1.LRU（再做一遍）
首先我们要明白我们放进数据结构的不是一个简单的数，而是一个对象，也就是说我们需要进行数据抽象化，假设每次放到数据结构的是一个node,这个node 包含key,value没问题，但是我们也设计了pre和next指针，方便查找调用具体的结点。最新插入的点都是插到尾结点的，所以我们每插入一个结点都不仅仅是将结点方到hashmap中还要判断是否超出了cache的capacity，超过了就要把头结点后的第一个结点删除。get结点的函数是要判断是不是有该结点，如果有就将该结点删除，然后将这个结点移到最后一个结点，因为该节点是最近才使用的结点。之所以使用双链表是因为我们需要对链表进行移除和插入操作，双链表比单链表操作要简单。为了避免查找特定的值的结点的时候我们都要进行链表遍历，我们设置了hashmap。在set函数中判断了有要插入的结点就应该return.判断需要插入的结点在不在链表中是get(key)!=-1,而不能用hs.containsKey(key)。这个还是要从题目的定义出发，题目给了get(key)的定义，if the key exists in the cache.

2.two sum(hash map)
因为这道题涉及到数和这个数所在的位置的对应关系，所以我们想到使用hashmap来做，但是在做的过程中我犯了一个错误，就是先往hashmap里面放数字，然后再逐个判断，这样就会存在一个问题，就是相同的数字的话位置就会被覆盖。应该将问题转换成减数和被减数两个数各自有对应的关系。因为题目中说了肯定有解，所以不需要进行数组是否有效的判断。
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        int[] results = new int[2];
        for(int i=0;i<nums.length;i++){
            int diff = target-nums[i];
            if(hm.containsKey(diff)){
                results[0] = i;
                results[1] = hm.get(diff);
            }else{
                hm.put(nums[i],i);
            }
        }
        return results;
    }

3.move zeroes(array)
这道题是让我们把所有的0都放到数组的最后并且不能改变其他数字的相对位置，我首先想到的方法就是对数组进行遍历，使用双指针的办法，如果我们第一个指针的值是0，第二个不是，那么就把两个数交换，如果第一个数不是0那么就把指向第一个数的指针往后移，如果第一个数是0，第二个数也是0就把第二个指针往后移。这个思想其实就是第一个指针指向非零的数，第二个指针指向零，这样遍历完就可以保证所有的零都在后面，而且因为遇到零就换了位置，所以相对的位置也不会改变。
public void moveZeroes(int[] nums) {
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]==0&&nums[j]!=0){
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }else if(nums[j] == 0){
                    continue;
                }else{
                    break;
                }
            }
        }
    }

4